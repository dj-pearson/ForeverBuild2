-- test_exploit_detection.lua
-- Comprehensive test suite for enterprise security systems
-- Tests SecurityValidator, RateLimiter, ExploitDetector, and BehaviorAnalyzer

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Test framework
local TestFramework = {}
TestFramework.__index = TestFramework

function TestFramework.new()
    local self = setmetatable({}, TestFramework)
    
    self.tests = {}
    self.results = {
        passed = 0,
        failed = 0,
        total = 0
    }
    
    return self
end

function TestFramework:AddTest(name, testFunction)
    table.insert(self.tests, {
        name = name,
        func = testFunction
    })
end

function TestFramework:RunTests()
    print("🧪 Starting Enterprise Security Test Suite")
    print("=" .. string.rep("=", 50))
    
    for _, test in ipairs(self.tests) do
        self.results.total = self.results.total + 1
        
        local success, result = pcall(test.func)
        
        if success and result then
            self.results.passed = self.results.passed + 1
            print("✅ PASS:", test.name)
        else
            self.results.failed = self.results.failed + 1
            print("❌ FAIL:", test.name, "-", result or "Unknown error")
        end
    end
    
    print("=" .. string.rep("=", 50))
    print(string.format("📊 Test Results: %d/%d passed (%.1f%%)", 
        self.results.passed, self.results.total, 
        (self.results.passed / self.results.total) * 100))
    
    if self.results.failed > 0 then
        print("⚠️  Some tests failed. Review security implementation.")
    else
        print("🎉 All tests passed! Security systems are working correctly.")
    end
end

-- Initialize test framework
local testFramework = TestFramework.new()

-- Load security modules for testing
local SecurityValidator, RateLimiter, ExploitDetector, BehaviorAnalyzer

local function loadSecurityModules()
    local success, result = pcall(function()
        SecurityValidator = require(ReplicatedStorage.src.shared.security.SecurityValidator)
        RateLimiter = require(ReplicatedStorage.src.shared.security.RateLimiter)
        ExploitDetector = require(ReplicatedStorage.src.shared.security.ExploitDetector)
        BehaviorAnalyzer = require(ReplicatedStorage.src.shared.security.BehaviorAnalyzer)
        return true
    end)
    
    if not success then
        warn("Failed to load security modules:", result)
        return false
    end
    
    print("✅ Security modules loaded successfully")
    return true
end

-- Test SecurityValidator
testFramework:AddTest("SecurityValidator - String Validation", function()
    if not SecurityValidator then return false end
    
    local validator = SecurityValidator.new()
    
    -- Test valid string
    local result1 = validator:ValidateString("ValidItemName", "ItemName", {maxLength = 50})
    if not result1.success then return false end
    
    -- Test invalid string (too long)
    local result2 = validator:ValidateString(string.rep("a", 200), "ItemName", {maxLength = 50})
    if result2.success then return false end
    
    -- Test invalid string (nil)
    local result3 = validator:ValidateString(nil, "ItemName", {maxLength = 50})
    if result3.success then return false end
    
    return true
end)

testFramework:AddTest("SecurityValidator - Position Validation", function()
    if not SecurityValidator then return false end
    
    local validator = SecurityValidator.new()
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Test valid position
    local result1 = validator:ValidatePosition(Vector3.new(10, 5, 10), mockPlayer)
    if not result1.success then return false end
    
    -- Test invalid position (too high)
    local result2 = validator:ValidatePosition(Vector3.new(10, 10000, 10), mockPlayer)
    if result2.success then return false end
    
    -- Test invalid position (nil)
    local result3 = validator:ValidatePosition(nil, mockPlayer)
    if result3.success then return false end
    
    return true
end)

testFramework:AddTest("SecurityValidator - Currency Validation", function()
    if not SecurityValidator then return false end
    
    local validator = SecurityValidator.new()
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Test valid currency amount
    local result1 = validator:ValidateCurrency(100, "INGAME", mockPlayer)
    if not result1.success then return false end
    
    -- Test invalid currency amount (negative)
    local result2 = validator:ValidateCurrency(-50, "INGAME", mockPlayer)
    if result2.success then return false end
    
    -- Test invalid currency amount (too large)
    local result3 = validator:ValidateCurrency(10000000, "INGAME", mockPlayer)
    if result3.success then return false end
    
    return true
end)

-- Test RateLimiter
testFramework:AddTest("RateLimiter - Basic Rate Limiting", function()
    if not RateLimiter then return false end
    
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- First request should be allowed
    local result1 = rateLimiter:CheckRateLimit(mockPlayer, "TestEndpoint", {})
    if not result1 then return false end
    
    -- Rapid subsequent requests should eventually be blocked
    local blocked = false
    for i = 1, 20 do
        local allowed, reason = rateLimiter:CheckRateLimit(mockPlayer, "TestEndpoint", {})
        if not allowed then
            blocked = true
            break
        end
    end
    
    return blocked
end)

testFramework:AddTest("RateLimiter - Endpoint Classification", function()
    if not RateLimiter then return false end
    
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Critical endpoints should have stricter limits
    local criticalAllowed = 0
    for i = 1, 10 do
        local allowed, reason = rateLimiter:CheckRateLimit(mockPlayer, "PlaceItem", {})
        if allowed then
            criticalAllowed = criticalAllowed + 1
        end
    end
    
    -- High frequency endpoints should allow more requests
    local highFreqAllowed = 0
    for i = 1, 10 do
        local allowed, reason = rateLimiter:CheckRateLimit(mockPlayer, "GetInventory", {})
        if allowed then
            highFreqAllowed = highFreqAllowed + 1
        end
    end
    
    -- High frequency should allow more than critical
    return highFreqAllowed > criticalAllowed
end)

-- Test ExploitDetector
testFramework:AddTest("ExploitDetector - Speed Detection", function()
    if not ExploitDetector then return false end
    
    local detector = ExploitDetector.new()
    detector:Initialize()
    
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Record normal movement
    detector:RecordAction(mockPlayer, "MOVE", {
        position = Vector3.new(0, 0, 0),
        timestamp = tick()
    })
    
    task.wait(0.1)
    
    -- Record suspicious fast movement
    detector:RecordAction(mockPlayer, "MOVE", {
        position = Vector3.new(100, 0, 0), -- 100 studs in 0.1 seconds = 1000 studs/second
        timestamp = tick()
    })
    
    -- Check if speed violation was detected
    local violations = detector:GetPlayerViolations(mockPlayer)
    
    return violations and #violations > 0
end)

testFramework:AddTest("ExploitDetector - Duplication Detection", function()
    if not ExploitDetector then return false end
    
    local detector = ExploitDetector.new()
    detector:Initialize()
    
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Simulate rapid item placement (potential duplication)
    for i = 1, 15 do
        detector:RecordAction(mockPlayer, "PLACE_ITEM", {
            itemId = "TestItem",
            timestamp = tick()
        })
    end
    
    -- Check if duplication violation was detected
    local violations = detector:GetPlayerViolations(mockPlayer)
    
    return violations and #violations > 0
end)

-- Test BehaviorAnalyzer
testFramework:AddTest("BehaviorAnalyzer - Pattern Recognition", function()
    if not BehaviorAnalyzer then return false end
    
    local analyzer = BehaviorAnalyzer.new()
    analyzer:Initialize()
    
    local mockPlayer = {UserId = 12345, Name = "TestPlayer"}
    
    -- Simulate repetitive bot-like behavior
    for i = 1, 20 do
        analyzer:RecordAction(mockPlayer, "CLICK", {
            position = Vector3.new(10, 5, 10), -- Same position every time
            timestamp = tick() + (i * 0.1) -- Exact timing intervals
        })
        task.wait(0.01)
    end
    
    -- Analyze behavior
    local analysis = analyzer:AnalyzePlayer(mockPlayer)
    
    -- Should detect suspicious patterns
    return analysis and analysis.riskLevel and analysis.riskLevel > 0.5
end)

testFramework:AddTest("BehaviorAnalyzer - Normal Behavior", function()
    if not BehaviorAnalyzer then return false end
    
    local analyzer = BehaviorAnalyzer.new()
    analyzer:Initialize()
    
    local mockPlayer = {UserId = 12346, Name = "NormalPlayer"}
    
    -- Simulate normal human behavior with variation
    for i = 1, 10 do
        analyzer:RecordAction(mockPlayer, "CLICK", {
            position = Vector3.new(
                math.random(-50, 50),
                math.random(0, 20),
                math.random(-50, 50)
            ),
            timestamp = tick() + (i * (0.5 + math.random() * 2)) -- Variable timing
        })
        task.wait(0.01)
    end
    
    -- Analyze behavior
    local analysis = analyzer:AnalyzePlayer(mockPlayer)
    
    -- Should not detect suspicious patterns
    return analysis and analysis.riskLevel and analysis.riskLevel < 0.3
end)

-- Integration tests
testFramework:AddTest("Integration - Security Validation Chain", function()
    if not SecurityValidator or not RateLimiter then return false end
    
    local validator = SecurityValidator.new()
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    
    local mockPlayer = {UserId = 12347, Name = "IntegrationTest"}
    
    -- Test complete validation chain
    local itemName = "TestItem"
    local position = Vector3.new(10, 5, 10)
    local currency = 100
    
    -- 1. Validate input
    local nameValidation = validator:ValidateString(itemName, "ItemName", {maxLength = 50})
    if not nameValidation.success then return false end
    
    local positionValidation = validator:ValidatePosition(position, mockPlayer)
    if not positionValidation.success then return false end
    
    local currencyValidation = validator:ValidateCurrency(currency, "INGAME", mockPlayer)
    if not currencyValidation.success then return false end
    
    -- 2. Check rate limits
    local rateLimitCheck = rateLimiter:CheckRateLimit(mockPlayer, "PlaceItem", {
        itemName = itemName,
        position = position
    })
    if not rateLimitCheck then return false end
    
    return true
end)

testFramework:AddTest("Integration - Admin Dashboard Data", function()
    -- Test that security modules can provide data for admin dashboard
    if not SecurityValidator or not RateLimiter or not ExploitDetector then return false end
    
    local validator = SecurityValidator.new()
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    local detector = ExploitDetector.new()
    detector:Initialize()
    
    -- Generate some test data
    local mockPlayer = {UserId = 12348, Name = "DashboardTest"}
    
    -- Create some violations
    validator:ValidateString(string.rep("x", 200), "Test", {maxLength = 50}) -- Should fail
    rateLimiter:CheckRateLimit(mockPlayer, "TestEndpoint", {})
    detector:RecordViolation(mockPlayer, "TEST_VIOLATION", "Test violation")
    
    -- Check that data can be retrieved
    local rateLimiterStats = rateLimiter:GetGlobalStats()
    local detectorViolations = detector:GetPlayerViolations(mockPlayer)
    
    return rateLimiterStats and rateLimiterStats.totalRequests and 
           detectorViolations and #detectorViolations > 0
end)

-- Performance tests
testFramework:AddTest("Performance - High Load Rate Limiting", function()
    if not RateLimiter then return false end
    
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    
    local startTime = tick()
    
    -- Simulate high load
    for i = 1, 1000 do
        local mockPlayer = {UserId = 10000 + i, Name = "LoadTest" .. i}
        rateLimiter:CheckRateLimit(mockPlayer, "LoadTest", {})
    end
    
    local endTime = tick()
    local duration = endTime - startTime
    
    -- Should complete within reasonable time (less than 1 second)
    return duration < 1.0
end)

testFramework:AddTest("Performance - Memory Usage", function()
    if not RateLimiter or not ExploitDetector then return false end
    
    local rateLimiter = RateLimiter.new()
    rateLimiter:Initialize()
    local detector = ExploitDetector.new()
    detector:Initialize()
    
    -- Generate data and then clean up
    for i = 1, 100 do
        local mockPlayer = {UserId = 20000 + i, Name = "MemoryTest" .. i}
        rateLimiter:CheckRateLimit(mockPlayer, "MemoryTest", {})
        detector:RecordAction(mockPlayer, "TEST", {timestamp = tick()})
    end
    
    -- Trigger cleanup
    rateLimiter:PerformCleanup(tick() + 1000) -- Force cleanup
    
    -- Check that cleanup worked (simplified check)
    local stats = rateLimiter:GetGlobalStats()
    
    return stats and stats.playersTracked ~= nil
end)

-- Main execution
local function runSecurityTests()
    print("🔒 Enterprise Security Test Suite")
    print("Testing: SecurityValidator, RateLimiter, ExploitDetector, BehaviorAnalyzer")
    print("")
    
    -- Load security modules
    if not loadSecurityModules() then
        print("❌ Failed to load security modules. Cannot run tests.")
        return
    end
    
    -- Run all tests
    testFramework:RunTests()
    
    -- Additional manual tests
    print("")
    print("🔧 Manual Test Instructions:")
    print("1. Press F9 (if admin) to open Admin Dashboard")
    print("2. Try rapid clicking in inventory to test rate limiting")
    print("3. Attempt to place items rapidly to test exploit detection")
    print("4. Monitor dashboard for real-time security metrics")
    print("")
    print("✅ Security test suite completed!")
end

-- Auto-run tests if this script is executed directly
if RunService:IsClient() then
    task.spawn(function()
        task.wait(2) -- Wait for modules to load
        runSecurityTests()
    end)
elseif RunService:IsServer() then
    task.spawn(function()
        task.wait(2) -- Wait for modules to load
        runSecurityTests()
    end)
end

return {
    runTests = runSecurityTests,
    testFramework = testFramework
} 