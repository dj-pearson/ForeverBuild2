-- ExploitDetector.luau
-- Enterprise-level exploit detection system
-- Detects speed hacking, teleportation, duplication, and other exploits

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local ExploitDetector = {}
ExploitDetector.__index = ExploitDetector

-- Configuration
local CONFIG = {
    -- Speed detection
    MAX_SPEED = 50, -- Maximum allowed speed (studs/second)
    SPEED_CHECK_INTERVAL = 0.5, -- How often to check speed
    SPEED_VIOLATION_THRESHOLD = 3, -- Violations before action
    
    -- Teleportation detection
    MAX_TELEPORT_DISTANCE = 100, -- Maximum distance between position updates
    TELEPORT_CHECK_INTERVAL = 0.1, -- How often to check position
    TELEPORT_VIOLATION_THRESHOLD = 2, -- Violations before action
    
    -- Duplication detection
    MAX_ACTIONS_PER_SECOND = 10, -- Maximum actions per second
    ACTION_WINDOW = 1, -- Time window for action counting
    DUPLICATION_VIOLATION_THRESHOLD = 3, -- Violations before action
    
    -- Behavioral analysis
    SUSPICIOUS_PATTERN_THRESHOLD = 5, -- Patterns before flagging
    BEHAVIOR_ANALYSIS_INTERVAL = 5, -- How often to analyze behavior
    
    -- General settings
    DEBUG_MODE = false,
    LOG_VIOLATIONS = true,
    AUTO_BAN_ENABLED = false, -- Set to true for automatic banning
    WARNING_THRESHOLD = 3, -- Warnings before escalation
}

-- Violation types
local VIOLATION_TYPES = {
    SPEED_HACK = "SPEED_HACK",
    TELEPORTATION = "TELEPORTATION", 
    DUPLICATION = "DUPLICATION",
    SUSPICIOUS_BEHAVIOR = "SUSPICIOUS_BEHAVIOR",
    INVALID_INPUT = "INVALID_INPUT",
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"
}

function ExploitDetector.new()
    local self = setmetatable({}, ExploitDetector)
    
    -- Player tracking data
    self.playerData = {}
    
    -- Violation tracking
    self.violations = {}
    
    -- Action tracking for duplication detection
    self.actionHistory = {}
    
    -- Connections for cleanup
    self.connections = {}
    
    -- Statistics
    self.stats = {
        totalViolations = 0,
        playersMonitored = 0,
        exploitsBlocked = 0,
        falsePositives = 0
    }
    
    return self
end

function ExploitDetector:Initialize()
    print("[ExploitDetector] Initializing exploit detection system...")
    
    -- Setup player tracking
    self:SetupPlayerTracking()
    
    -- Start monitoring loops
    self:StartSpeedMonitoring()
    self:StartTeleportMonitoring()
    self:StartBehaviorAnalysis()
    
    -- Setup remote events for client-server communication
    self:SetupRemoteEvents()
    
    print("[ExploitDetector] Exploit detection system initialized")
    return true
end

function ExploitDetector:SetupPlayerTracking()
    -- Track existing players
    for _, player in ipairs(Players:GetPlayers()) do
        self:InitializePlayerData(player)
    end
    
    -- Track new players
    local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerData(player)
    end)
    table.insert(self.connections, playerAddedConnection)
    
    -- Clean up when players leave
    local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerData(player)
    end)
    table.insert(self.connections, playerRemovingConnection)
end

function ExploitDetector:InitializePlayerData(player)
    local userId = player.UserId
    
    self.playerData[userId] = {
        player = player,
        lastPosition = nil,
        lastPositionTime = 0,
        speedViolations = 0,
        teleportViolations = 0,
        duplicationViolations = 0,
        totalViolations = 0,
        warnings = 0,
        joinTime = tick(),
        lastActionTime = 0,
        actionsThisSecond = 0,
        behaviorPatterns = {},
        suspiciousScore = 0
    }
    
    self.violations[userId] = {}
    self.actionHistory[userId] = {}
    
    self.stats.playersMonitored = self.stats.playersMonitored + 1
    
    if CONFIG.DEBUG_MODE then
        print("[ExploitDetector] Initialized tracking for player:", player.Name)
    end
end

function ExploitDetector:CleanupPlayerData(player)
    local userId = player.UserId
    
    self.playerData[userId] = nil
    self.violations[userId] = nil
    self.actionHistory[userId] = nil
    
    if CONFIG.DEBUG_MODE then
        print("[ExploitDetector] Cleaned up data for player:", player.Name)
    end
end

function ExploitDetector:StartSpeedMonitoring()
    local speedConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        
        for userId, data in pairs(self.playerData) do
            if currentTime - data.lastPositionTime >= CONFIG.SPEED_CHECK_INTERVAL then
                self:CheckPlayerSpeed(data)
                data.lastPositionTime = currentTime
            end
        end
    end)
    
    table.insert(self.connections, speedConnection)
    
    if CONFIG.DEBUG_MODE then
        print("[ExploitDetector] Speed monitoring started")
    end
end

function ExploitDetector:CheckPlayerSpeed(playerData)
    local player = playerData.player
    if not player or not player.Parent then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local currentPosition = humanoidRootPart.Position
    local currentTime = tick()
    
    if playerData.lastPosition then
        local distance = (currentPosition - playerData.lastPosition).Magnitude
        local timeDelta = currentTime - playerData.lastPositionTime
        
        if timeDelta > 0 then
            local speed = distance / timeDelta
            
            if speed > CONFIG.MAX_SPEED then
                self:RecordViolation(player, VIOLATION_TYPES.SPEED_HACK, {
                    speed = speed,
                    maxSpeed = CONFIG.MAX_SPEED,
                    distance = distance,
                    timeDelta = timeDelta
                })
                
                playerData.speedViolations = playerData.speedViolations + 1
                
                if playerData.speedViolations >= CONFIG.SPEED_VIOLATION_THRESHOLD then
                    self:HandleViolation(player, VIOLATION_TYPES.SPEED_HACK)
                end
            end
        end
    end
    
    playerData.lastPosition = currentPosition
end

function ExploitDetector:StartTeleportMonitoring()
    local teleportConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        
        for userId, data in pairs(self.playerData) do
            if currentTime - data.lastPositionTime >= CONFIG.TELEPORT_CHECK_INTERVAL then
                self:CheckPlayerTeleportation(data)
            end
        end
    end)
    
    table.insert(self.connections, teleportConnection)
    
    if CONFIG.DEBUG_MODE then
        print("[ExploitDetector] Teleportation monitoring started")
    end
end

function ExploitDetector:CheckPlayerTeleportation(playerData)
    local player = playerData.player
    if not player or not player.Parent then return end
    
    local character = player.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local currentPosition = humanoidRootPart.Position
    local currentTime = tick()
    
    if playerData.lastPosition then
        local distance = (currentPosition - playerData.lastPosition).Magnitude
        local timeDelta = currentTime - playerData.lastPositionTime
        
        -- Check for instant teleportation (large distance in small time)
        if timeDelta < 0.2 and distance > CONFIG.MAX_TELEPORT_DISTANCE then
            self:RecordViolation(player, VIOLATION_TYPES.TELEPORTATION, {
                distance = distance,
                maxDistance = CONFIG.MAX_TELEPORT_DISTANCE,
                timeDelta = timeDelta,
                fromPosition = playerData.lastPosition,
                toPosition = currentPosition
            })
            
            playerData.teleportViolations = playerData.teleportViolations + 1
            
            if playerData.teleportViolations >= CONFIG.TELEPORT_VIOLATION_THRESHOLD then
                self:HandleViolation(player, VIOLATION_TYPES.TELEPORTATION)
            end
        end
    end
end

function ExploitDetector:StartBehaviorAnalysis()
    local behaviorConnection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        
        for userId, data in pairs(self.playerData) do
            if currentTime - data.lastActionTime >= CONFIG.BEHAVIOR_ANALYSIS_INTERVAL then
                self:AnalyzePlayerBehavior(data)
                data.lastActionTime = currentTime
            end
        end
    end)
    
    table.insert(self.connections, behaviorConnection)
    
    if CONFIG.DEBUG_MODE then
        print("[ExploitDetector] Behavior analysis started")
    end
end

function ExploitDetector:AnalyzePlayerBehavior(playerData)
    local player = playerData.player
    if not player or not player.Parent then return end
    
    local userId = player.UserId
    local actionHistory = self.actionHistory[userId] or {}
    
    -- Analyze action patterns
    local recentActions = {}
    local currentTime = tick()
    
    -- Get actions from the last minute
    for _, action in ipairs(actionHistory) do
        if currentTime - action.timestamp <= 60 then
            table.insert(recentActions, action)
        end
    end
    
    -- Check for suspicious patterns
    local suspiciousScore = 0
    
    -- Pattern 1: Too many identical actions
    local actionCounts = {}
    for _, action in ipairs(recentActions) do
        actionCounts[action.type] = (actionCounts[action.type] or 0) + 1
    end
    
    for actionType, count in pairs(actionCounts) do
        if count > CONFIG.MAX_ACTIONS_PER_SECOND * 10 then -- 10 seconds worth
            suspiciousScore = suspiciousScore + 2
        end
    end
    
    -- Pattern 2: Perfect timing (bot-like behavior)
    local timings = {}
    for i = 2, #recentActions do
        local timeDiff = recentActions[i].timestamp - recentActions[i-1].timestamp
        table.insert(timings, timeDiff)
    end
    
    if #timings > 5 then
        local avgTiming = 0
        for _, timing in ipairs(timings) do
            avgTiming = avgTiming + timing
        end
        avgTiming = avgTiming / #timings
        
        local variance = 0
        for _, timing in ipairs(timings) do
            variance = variance + (timing - avgTiming)^2
        end
        variance = variance / #timings
        
        -- Very low variance suggests bot behavior
        if variance < 0.01 and #timings > 10 then
            suspiciousScore = suspiciousScore + 3
        end
    end
    
    playerData.suspiciousScore = suspiciousScore
    
    if suspiciousScore >= CONFIG.SUSPICIOUS_PATTERN_THRESHOLD then
        self:RecordViolation(player, VIOLATION_TYPES.SUSPICIOUS_BEHAVIOR, {
            suspiciousScore = suspiciousScore,
            threshold = CONFIG.SUSPICIOUS_PATTERN_THRESHOLD,
            recentActionCount = #recentActions,
            patterns = actionCounts
        })
        
        self:HandleViolation(player, VIOLATION_TYPES.SUSPICIOUS_BEHAVIOR)
    end
end

function ExploitDetector:RecordAction(player, actionType, actionData)
    local userId = player.UserId
    if not self.actionHistory[userId] then
        self.actionHistory[userId] = {}
    end
    
    local action = {
        type = actionType,
        data = actionData or {},
        timestamp = tick()
    }
    
    table.insert(self.actionHistory[userId], action)
    
    -- Clean up old actions (keep only last 100)
    if #self.actionHistory[userId] > 100 then
        table.remove(self.actionHistory[userId], 1)
    end
    
    -- Check for duplication exploits
    self:CheckDuplicationExploit(player, actionType)
end

function ExploitDetector:CheckDuplicationExploit(player, actionType)
    local userId = player.UserId
    local playerData = self.playerData[userId]
    if not playerData then return end
    
    local currentTime = tick()
    local actionHistory = self.actionHistory[userId] or {}
    
    -- Count actions in the last second
    local actionsInLastSecond = 0
    for _, action in ipairs(actionHistory) do
        if currentTime - action.timestamp <= CONFIG.ACTION_WINDOW then
            actionsInLastSecond = actionsInLastSecond + 1
        end
    end
    
    if actionsInLastSecond > CONFIG.MAX_ACTIONS_PER_SECOND then
        self:RecordViolation(player, VIOLATION_TYPES.DUPLICATION, {
            actionsPerSecond = actionsInLastSecond,
            maxAllowed = CONFIG.MAX_ACTIONS_PER_SECOND,
            actionType = actionType
        })
        
        playerData.duplicationViolations = playerData.duplicationViolations + 1
        
        if playerData.duplicationViolations >= CONFIG.DUPLICATION_VIOLATION_THRESHOLD then
            self:HandleViolation(player, VIOLATION_TYPES.DUPLICATION)
        end
    end
end

function ExploitDetector:RecordViolation(player, violationType, violationData)
    local userId = player.UserId
    if not self.violations[userId] then
        self.violations[userId] = {}
    end
    
    local violation = {
        type = violationType,
        data = violationData,
        timestamp = tick(),
        playerId = userId,
        playerName = player.Name
    }
    
    table.insert(self.violations[userId], violation)
    
    -- Update player data
    local playerData = self.playerData[userId]
    if playerData then
        playerData.totalViolations = playerData.totalViolations + 1
    end
    
    -- Update global stats
    self.stats.totalViolations = self.stats.totalViolations + 1
    
    if CONFIG.LOG_VIOLATIONS then
        warn(string.format("üö® EXPLOIT DETECTED: Player %s (%d) - %s", 
            player.Name, userId, violationType))
        
        if CONFIG.DEBUG_MODE then
            print("Violation data:", HttpService:JSONEncode(violationData))
        end
    end
end

function ExploitDetector:HandleViolation(player, violationType)
    local userId = player.UserId
    local playerData = self.playerData[userId]
    if not playerData then return end
    
    playerData.warnings = playerData.warnings + 1
    
    -- Escalation based on warning count
    if playerData.warnings >= CONFIG.WARNING_THRESHOLD then
        if CONFIG.AUTO_BAN_ENABLED then
            self:BanPlayer(player, violationType)
        else
            self:NotifyAdmins(player, violationType)
        end
    else
        self:WarnPlayer(player, violationType)
    end
    
    self.stats.exploitsBlocked = self.stats.exploitsBlocked + 1
end

function ExploitDetector:WarnPlayer(player, violationType)
    -- Send warning to player
    local remoteEvent = ReplicatedStorage:FindFirstChild("ExploitWarning")
    if remoteEvent then
        remoteEvent:FireClient(player, violationType)
    end
    
    print(string.format("‚ö†Ô∏è WARNING: Player %s warned for %s", player.Name, violationType))
end

function ExploitDetector:BanPlayer(player, violationType)
    -- Implement banning logic here
    print(string.format("üî® BAN: Player %s banned for %s", player.Name, violationType))
    
    -- You would integrate with your ban system here
    -- player:Kick("You have been banned for exploiting")
end

function ExploitDetector:NotifyAdmins(player, violationType)
    -- Notify administrators about the violation
    print(string.format("üëÆ ADMIN ALERT: Player %s requires attention for %s", player.Name, violationType))
    
    -- You could send this to a Discord webhook or admin panel
end

function ExploitDetector:SetupRemoteEvents()
    -- Create remote events for client-server communication
    local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
    if not remotesFolder then
        remotesFolder = Instance.new("Folder")
        remotesFolder.Name = "Remotes"
        remotesFolder.Parent = ReplicatedStorage
    end
    
    -- Create exploit warning remote
    local exploitWarning = remotesFolder:FindFirstChild("ExploitWarning")
    if not exploitWarning then
        exploitWarning = Instance.new("RemoteEvent")
        exploitWarning.Name = "ExploitWarning"
        exploitWarning.Parent = remotesFolder
    end
end

function ExploitDetector:GetPlayerStats(player)
    local userId = player.UserId
    local playerData = self.playerData[userId]
    local violations = self.violations[userId] or {}
    
    if not playerData then
        return nil
    end
    
    return {
        totalViolations = playerData.totalViolations,
        speedViolations = playerData.speedViolations,
        teleportViolations = playerData.teleportViolations,
        duplicationViolations = playerData.duplicationViolations,
        warnings = playerData.warnings,
        suspiciousScore = playerData.suspiciousScore,
        joinTime = playerData.joinTime,
        violationHistory = violations
    }
end

function ExploitDetector:GetGlobalStats()
    return {
        totalViolations = self.stats.totalViolations,
        playersMonitored = self.stats.playersMonitored,
        exploitsBlocked = self.stats.exploitsBlocked,
        falsePositives = self.stats.falsePositives,
        activeConnections = #self.connections
    }
end

function ExploitDetector:Cleanup()
    print("[ExploitDetector] Cleaning up...")
    
    -- Disconnect all connections
    for _, connection in ipairs(self.connections) do
        if connection then
            connection:Disconnect()
        end
    end
    self.connections = {}
    
    -- Clear data
    self.playerData = {}
    self.violations = {}
    self.actionHistory = {}
    
    print("[ExploitDetector] Cleanup complete")
end

return ExploitDetector 