-- AntiExploitSystem.luau
-- Comprehensive anti-exploit protection system

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")

local AntiExploitSystem = {}
AntiExploitSystem.__index = AntiExploitSystem

-- DataStore for exploit tracking
local ExploitStore = DataStoreService:GetDataStore("ExploitTracking_v1")

function AntiExploitSystem.new(placementTracker, moderationSystem)
    local self = setmetatable({}, AntiExploitSystem)
    
    self.placementTracker = placementTracker
    self.moderationSystem = moderationSystem
    
    -- Rate limiting and validation
    self.rateLimits = {
        placement = {maxPerSecond = 2, window = 60},
        purchase = {maxPerSecond = 1, window = 30},
        movement = {maxPerSecond = 5, window = 10},
        rotation = {maxPerSecond = 3, window = 10}
    }
    
    -- Player tracking
    self.playerTracking = {}
    self.exploitAttempts = {}
    
    -- Security rules
    self.securityRules = {
        maxPlacementDistance = 50,  -- Max distance from player to place objects
        maxMovementSpeed = 100,     -- Max reasonable movement speed
        maxItemValue = 10000,       -- Max item value that can be purchased
        serverAuthorityMode = true, -- All operations must be server-validated
        strictPositionValidation = true,
        validatePlayerOwnership = true,
        logSuspiciousActivity = true
    }
    
    -- Known exploit patterns
    self.exploitPatterns = {
        speedHacking = {threshold = 200, duration = 5},
        itemDuplication = {sameItemThreshold = 10, timeWindow = 60},
        positionTeleporting = {distanceThreshold = 500, timeThreshold = 1},
        rapidFiring = {actionThreshold = 100, timeWindow = 10},
        invalidPositions = {outOfBounds = true, impossibleY = true}
    }
    
    self:Initialize()
    return self
end

function AntiExploitSystem:Initialize()
    -- Start monitoring systems
    self:StartPlayerTracking()
    self:StartExploitDetection()
    self:StartValidationChecks()
    
    -- Handle player connections
    Players.PlayerAdded:Connect(function(player)
        self:InitializePlayerTracking(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:CleanupPlayerTracking(player)
    end)
    
    print("🔒 Anti-exploit system initialized")
end

-- Player tracking initialization
function AntiExploitSystem:InitializePlayerTracking(player)
    self.playerTracking[player.UserId] = {
        joinTime = os.time(),
        lastPosition = Vector3.new(0, 0, 0),
        lastUpdate = os.time(),
        actionCounts = {
            placement = {},
            purchase = {},
            movement = {},
            rotation = {}
        },
        suspicionLevel = 0,
        violations = {},
        isMonitored = true
    }
    
    print("🔍 Initialized tracking for player:", player.Name)
end

function AntiExploitSystem:CleanupPlayerTracking(player)
    -- Save violation history before cleanup
    if self.playerTracking[player.UserId] and #self.playerTracking[player.UserId].violations > 0 then
        self:SaveViolationHistory(player.UserId, self.playerTracking[player.UserId].violations)
    end
    
    self.playerTracking[player.UserId] = nil
end

-- Core validation functions
function AntiExploitSystem:ValidatePlacement(player, itemData, position, rotation)
    local violations = {}
    
    -- 1. Rate limiting check
    if not self:CheckRateLimit(player, "placement") then
        table.insert(violations, {
            type = "RATE_LIMIT_EXCEEDED",
            action = "placement",
            severity = 3
        })
    end
    
    -- 2. Distance validation
    if not self:ValidatePlacementDistance(player, position) then
        table.insert(violations, {
            type = "INVALID_PLACEMENT_DISTANCE",
            position = position,
            severity = 4
        })
    end
    
    -- 3. Position validation
    if not self:ValidatePosition(position) then
        table.insert(violations, {
            type = "INVALID_POSITION",
            position = position,
            severity = 5
        })
    end
    
    -- 4. Item validation
    if not self:ValidateItemData(itemData) then
        table.insert(violations, {
            type = "INVALID_ITEM_DATA",
            itemData = itemData,
            severity = 5
        })
    end
    
    -- 5. Ownership validation
    if not self:ValidateItemOwnership(player, itemData) then
        table.insert(violations, {
            type = "ITEM_OWNERSHIP_VIOLATION",
            itemData = itemData,
            severity = 5
        })
    end
    
    -- Process violations
    if #violations > 0 then
        self:ProcessViolations(player, violations)
        return false, violations
    end
    
    -- Record successful action
    self:RecordValidAction(player, "placement")
    return true, nil
end

function AntiExploitSystem:ValidatePurchase(player, itemId, cost, currency)
    local violations = {}
    
    -- 1. Rate limiting
    if not self:CheckRateLimit(player, "purchase") then
        table.insert(violations, {
            type = "PURCHASE_RATE_LIMIT",
            severity = 2
        })
    end
    
    -- 2. Cost validation (server-authoritative)
    local serverCost = self:GetServerItemCost(itemId, currency)
    if cost ~= serverCost then
        table.insert(violations, {
            type = "COST_MANIPULATION",
            clientCost = cost,
            serverCost = serverCost,
            severity = 5
        })
    end
    
    -- 3. Currency validation
    if not self:ValidateCurrencyAmount(player, cost, currency) then
        table.insert(violations, {
            type = "INSUFFICIENT_CURRENCY",
            severity = 1
        })
    end
    
    -- 4. Item existence validation
    if not self:ValidateItemExists(itemId) then
        table.insert(violations, {
            type = "INVALID_ITEM_ID",
            itemId = itemId,
            severity = 3
        })
    end
    
    if #violations > 0 then
        self:ProcessViolations(player, violations)
        return false, violations
    end
    
    self:RecordValidAction(player, "purchase")
    return true, nil
end

function AntiExploitSystem:ValidateMovement(player, oldPosition, newPosition)
    local violations = {}
    
    -- 1. Movement speed check
    local distance = (newPosition - oldPosition).Magnitude
    local timeDelta = os.time() - (self.playerTracking[player.UserId].lastUpdate or os.time())
    local speed = distance / math.max(timeDelta, 0.1)
    
    if speed > self.securityRules.maxMovementSpeed then
        table.insert(violations, {
            type = "SPEED_HACKING",
            speed = speed,
            maxAllowed = self.securityRules.maxMovementSpeed,
            severity = 4
        })
    end
    
    -- 2. Teleportation check
    if distance > self.exploitPatterns.positionTeleporting.distanceThreshold and timeDelta < self.exploitPatterns.positionTeleporting.timeThreshold then
        table.insert(violations, {
            type = "POSITION_TELEPORTING",
            distance = distance,
            timeDelta = timeDelta,
            severity = 5
        })
    end
    
    -- 3. Position bounds check
    if not self:ValidatePosition(newPosition) then
        table.insert(violations, {
            type = "OUT_OF_BOUNDS_MOVEMENT",
            position = newPosition,
            severity = 3
        })
    end
    
    if #violations > 0 then
        self:ProcessViolations(player, violations)
        return false, violations
    end
    
    -- Update tracking
    if self.playerTracking[player.UserId] then
        self.playerTracking[player.UserId].lastPosition = newPosition
        self.playerTracking[player.UserId].lastUpdate = os.time()
    end
    
    return true, nil
end

-- Rate limiting
function AntiExploitSystem:CheckRateLimit(player, actionType)
    local tracking = self.playerTracking[player.UserId]
    if not tracking then return false end
    
    local limit = self.rateLimits[actionType]
    if not limit then return true end
    
    local currentTime = os.time()
    local actions = tracking.actionCounts[actionType]
    
    -- Clean old actions outside window
    for i = #actions, 1, -1 do
        if currentTime - actions[i] > limit.window then
            table.remove(actions, i)
        end
    end
    
    -- Check if under limit
    local actionsInWindow = #actions
    local maxActions = limit.maxPerSecond * (limit.window / 60)
    
    return actionsInWindow < maxActions
end

function AntiExploitSystem:RecordValidAction(player, actionType)
    local tracking = self.playerTracking[player.UserId]
    if tracking then
        table.insert(tracking.actionCounts[actionType], os.time())
    end
end

-- Validation helpers
function AntiExploitSystem:ValidatePlacementDistance(player, position)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local playerPosition = player.Character.HumanoidRootPart.Position
    local distance = (position - playerPosition).Magnitude
    
    return distance <= self.securityRules.maxPlacementDistance
end

function AntiExploitSystem:ValidatePosition(position)
    -- Check for NaN or infinite values
    if position.X ~= position.X or position.Y ~= position.Y or position.Z ~= position.Z then
        return false
    end
    
    if math.abs(position.X) == math.huge or math.abs(position.Y) == math.huge or math.abs(position.Z) == math.huge then
        return false
    end
    
    -- Check world bounds
    local bounds = {
        minX = -10000, maxX = 10000,
        minY = -1000, maxY = 10000,
        minZ = -10000, maxZ = 10000
    }
    
    if position.X < bounds.minX or position.X > bounds.maxX or
       position.Y < bounds.minY or position.Y > bounds.maxY or
       position.Z < bounds.minZ or position.Z > bounds.maxZ then
        return false
    end
    
    return true
end

function AntiExploitSystem:ValidateItemData(itemData)
    if not itemData or typeof(itemData) ~= "table" then
        return false
    end
    
    -- Required fields
    if not itemData.ItemId or not itemData.Name then
        return false
    end
    
    -- Validate ItemId is reasonable
    if typeof(itemData.ItemId) ~= "number" or itemData.ItemId <= 0 or itemData.ItemId > 999999 then
        return false
    end
    
    -- Validate name
    if typeof(itemData.Name) ~= "string" or #itemData.Name == 0 or #itemData.Name > 100 then
        return false
    end
    
    return true
end

function AntiExploitSystem:ValidateItemOwnership(player, itemData)
    -- This would integrate with your inventory system
    -- For now, basic validation
    return true -- Placeholder - implement actual ownership check
end

function AntiExploitSystem:GetServerItemCost(itemId, currency)
    -- Server-authoritative pricing
    -- This should integrate with your Constants or pricing system
    local defaultCosts = {
        [12345] = {INGAME = 100, ROBUX = 10},
        [12346] = {INGAME = 150, ROBUX = 15}
    }
    
    local item = defaultCosts[itemId]
    if item and item[currency] then
        return item[currency]
    end
    
    return 0 -- Free if not found (or implement proper lookup)
end

function AntiExploitSystem:ValidateCurrencyAmount(player, cost, currency)
    -- This would check player's actual currency
    -- Placeholder implementation
    return true
end

function AntiExploitSystem:ValidateItemExists(itemId)
    -- Validate item exists in server data
    return typeof(itemId) == "number" and itemId > 0
end

-- Exploit detection
function AntiExploitSystem:StartExploitDetection()
    spawn(function()
        while true do
            wait(5) -- Check every 5 seconds
            self:DetectExploitPatterns()
        end
    end)
end

function AntiExploitSystem:DetectExploitPatterns()
    for userId, tracking in pairs(self.playerTracking) do
        local player = Players:GetPlayerByUserId(userId)
        if player then
            -- Speed hacking detection
            self:CheckSpeedHacking(player, tracking)
            
            -- Item duplication detection
            self:CheckItemDuplication(player, tracking)
            
            -- Rapid action detection
            self:CheckRapidActions(player, tracking)
        end
    end
end

function AntiExploitSystem:CheckSpeedHacking(player, tracking)
    if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local currentPosition = player.Character.HumanoidRootPart.Position
    local lastPosition = tracking.lastPosition
    local timeDelta = os.time() - tracking.lastUpdate
    
    if timeDelta > 0 then
        local distance = (currentPosition - lastPosition).Magnitude
        local speed = distance / timeDelta
        
        if speed > self.exploitPatterns.speedHacking.threshold then
            self:FlagExploit(player, "SPEED_HACKING", {
                speed = speed,
                threshold = self.exploitPatterns.speedHacking.threshold
            })
        end
    end
    
    tracking.lastPosition = currentPosition
    tracking.lastUpdate = os.time()
end

function AntiExploitSystem:CheckItemDuplication(player, tracking)
    -- This would check for suspicious item creation patterns
    -- Placeholder for now
end

function AntiExploitSystem:CheckRapidActions(player, tracking)
    local currentTime = os.time()
    
    for actionType, actions in pairs(tracking.actionCounts) do
        local recentActions = 0
        for _, timestamp in ipairs(actions) do
            if currentTime - timestamp <= self.exploitPatterns.rapidFiring.timeWindow then
                recentActions = recentActions + 1
            end
        end
        
        if recentActions > self.exploitPatterns.rapidFiring.actionThreshold then
            self:FlagExploit(player, "RAPID_ACTIONS", {
                actionType = actionType,
                count = recentActions,
                timeWindow = self.exploitPatterns.rapidFiring.timeWindow
            })
        end
    end
end

-- Violation processing
function AntiExploitSystem:ProcessViolations(player, violations)
    local tracking = self.playerTracking[player.UserId]
    if not tracking then return end
    
    local totalSeverity = 0
    for _, violation in ipairs(violations) do
        totalSeverity = totalSeverity + violation.severity
        table.insert(tracking.violations, {
            type = violation.type,
            severity = violation.severity,
            timestamp = os.time(),
            details = violation
        })
    end
    
    tracking.suspicionLevel = tracking.suspicionLevel + totalSeverity
    
    -- Log violations
    for _, violation in ipairs(violations) do
        warn("🚨 EXPLOIT ATTEMPT by", player.Name, ":", violation.type, "Severity:", violation.severity)
    end
    
    -- Determine response
    if totalSeverity >= 10 then
        self:HandleSevereViolation(player, violations)
    elseif totalSeverity >= 5 then
        self:HandleModerateViolation(player, violations)
    else
        self:HandleMinorViolation(player, violations)
    end
    
    -- Integrate with moderation system
    if self.moderationSystem then
        for _, violation in ipairs(violations) do
            self.moderationSystem:RecordPlayerViolation(player, {violation})
        end
    end
end

function AntiExploitSystem:FlagExploit(player, exploitType, details)
    local violation = {
        type = exploitType,
        severity = 4,
        details = details,
        timestamp = os.time()
    }
    
    self:ProcessViolations(player, {violation})
end

-- Response handling
function AntiExploitSystem:HandleSevereViolation(player, violations)
    warn("🔨 SEVERE EXPLOIT VIOLATION by", player.Name, "- Immediate kick")
    
    -- Save evidence
    self:SaveExploitEvidence(player, violations)
    
    -- Immediate kick
    player:Kick("Severe exploit violation detected. Your actions have been logged.")
end

function AntiExploitSystem:HandleModerateViolation(player, violations)
    warn("⚠️ MODERATE EXPLOIT VIOLATION by", player.Name, "- Warning issued")
    
    -- Issue warning
    self:NotifyPlayer(player, "Warning: Suspicious activity detected. Continued violations may result in a ban.")
    
    -- Increase monitoring
    if self.playerTracking[player.UserId] then
        self.playerTracking[player.UserId].isMonitored = true
    end
end

function AntiExploitSystem:HandleMinorViolation(player, violations)
    print("ℹ️ Minor violation by", player.Name, "- Logged for monitoring")
end

-- Utility functions
function AntiExploitSystem:NotifyPlayer(player, message)
    -- Send notification to player
    print("📢 Notifying", player.Name, ":", message)
    -- Implement actual notification system here
end

function AntiExploitSystem:SaveExploitEvidence(player, violations)
    local evidence = {
        playerId = player.UserId,
        playerName = player.Name,
        violations = violations,
        timestamp = os.time(),
        sessionData = self.playerTracking[player.UserId]
    }
    
    pcall(function()
        ExploitStore:SetAsync("EXPLOIT_" .. player.UserId .. "_" .. os.time(), evidence)
    end)
end

function AntiExploitSystem:SaveViolationHistory(userId, violations)
    pcall(function()
        ExploitStore:SetAsync("HISTORY_" .. userId, violations)
    end)
end

-- Server authority enforcement
function AntiExploitSystem:EnforceServerAuthority()
    -- All placement operations must go through server validation
    -- This would integrate with your existing placement system
    print("🔒 Server authority mode: All operations require server validation")
end

-- Admin functions
function AntiExploitSystem:GetPlayerSuspicionLevel(player)
    local tracking = self.playerTracking[player.UserId]
    return tracking and tracking.suspicionLevel or 0
end

function AntiExploitSystem:GetPlayerViolations(player)
    local tracking = self.playerTracking[player.UserId]
    return tracking and tracking.violations or {}
end

function AntiExploitSystem:ResetPlayerViolations(player)
    local tracking = self.playerTracking[player.UserId]
    if tracking then
        tracking.violations = {}
        tracking.suspicionLevel = 0
        print("🔧 Reset violations for player:", player.Name)
    end
end

-- Monitoring and reporting
function AntiExploitSystem:StartValidationChecks()
    spawn(function()
        while true do
            wait(60) -- Generate report every minute
            self:GenerateSecurityReport()
        end
    end)
end

function AntiExploitSystem:GenerateSecurityReport()
    local report = {
        timestamp = os.time(),
        totalPlayers = #Players:GetPlayers(),
        suspiciousPlayers = 0,
        totalViolations = 0,
        severityBreakdown = {
            minor = 0,
            moderate = 0,
            severe = 0
        }
    }
    
    for userId, tracking in pairs(self.playerTracking) do
        if tracking.suspicionLevel > 0 then
            report.suspiciousPlayers = report.suspiciousPlayers + 1
        end
        
        report.totalViolations = report.totalViolations + #tracking.violations
        
        for _, violation in ipairs(tracking.violations) do
            if violation.severity <= 2 then
                report.severityBreakdown.minor = report.severityBreakdown.minor + 1
            elseif violation.severity <= 4 then
                report.severityBreakdown.moderate = report.severityBreakdown.moderate + 1
            else
                report.severityBreakdown.severe = report.severityBreakdown.severe + 1
            end
        end
    end
    
    if report.totalViolations > 0 then
        print("🔒 Security Report:")
        print("   Suspicious Players:", report.suspiciousPlayers, "/", report.totalPlayers)
        print("   Total Violations:", report.totalViolations)
        print("   Severity: Minor:", report.severityBreakdown.minor, "Moderate:", report.severityBreakdown.moderate, "Severe:", report.severityBreakdown.severe)
    end
    
    return report
end

return AntiExploitSystem 