<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">shared</string>
        <string name="Source"><![CDATA[--[[
    Shared Module - ForeverBuild2
    
    This is the main entry point for all shared modules.
    When requiring this module, you'll get access to all sub-modules.
]]

local SharedModule = {}

SharedModule.Constants = require(script.core.Constants)
SharedModule.GameManager = require(script.core.GameManager)
SharedModule.UI = require(script.core.ui)
SharedModule.Interaction = require(script.core.interaction)
SharedModule.Placement = require(script.core.placement)
SharedModule.Inventory = require(script.core.inventory)
SharedModule.Economy = require(script.core.economy)

function SharedModule.Init()
    print("Initializing SharedModule...")

    -- Initialize submodules if they have Init/Initialize
    for _, sub in pairs({
        SharedModule.GameManager,
        SharedModule.UI,
        SharedModule.Interaction,
        SharedModule.Placement,
        SharedModule.Inventory,
        SharedModule.Economy
    }) do
        if sub.Init then sub.Init() end
        if sub.Initialize then sub.Initialize() end
    end

    return true
end

return SharedModule
]]></string>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">core</string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">Constants</string>
            <string name="Source">local Color3 = Color3

local Constants = {
    -- Currency
    CURRENCY = {
        STARTING_COINS = 100,
        MAX_COINS = 999999,
        REWARD_INTERVAL = 60, -- seconds
        REWARD_RATE = 1, -- coins per minute
        MIN_REWARD_AMOUNT = 1,
        MAX_REWARD_AMOUNT = 10,
        DAILY_BONUS = 50,
        WEEKLY_BONUS = 500,
        MONTHLY_BONUS = 2000,
        PRODUCTS = {
            {
                id = 1,
                coins = 100,
                robux = 10
            },
            {
                id = 2,
                coins = 500,
                robux = 40
            },
            {
                id = 3,
                coins = 1000,
                robux = 75
            },
            {
                id = 4,
                coins = 5000,
                robux = 350
            }
        }
    },
    
    -- UI
    UI_COLORS = {
        PRIMARY = Color3.fromRGB(0, 170, 255),
        SECONDARY = Color3.fromRGB(40, 40, 40),
        TEXT = Color3.fromRGB(255, 255, 255),
        ERROR = Color3.fromRGB(255, 50, 50)
    },
    
    -- Game Settings
    GAME = {
        MAX_INVENTORY_SLOTS = 50,
        PLACEMENT_COOLDOWN = 0.5,
        MAX_PLACEMENTS_PER_PLAYER = 1000,
        STARTING_CURRENCY = 1000,
        MAX_PLACED_ITEMS = 100
    },
    
    -- Item Actions
    ITEM_ACTIONS = {
        BUY = "buy",
        MOVE = "move",
        ROTATE = "rotate",
        COLOR = "color",
        DESTROY = "destroy",
        clone = {
            cost = 50,
            description = "Create a copy of this item"
        },
        move = {
            cost = 25,
            description = "Move this item to a new location"
        },
        rotate = {
            cost = 10,
            description = "Rotate this item"
        },
        destroy = {
            cost = 0,
            description = "Remove this item"
        }
    },

    ITEM_PRICING = {
        basic = 5,        -- 5 Robux
        secondary = 20,   -- 20 Robux
        rare = 100,       -- 100 Robux
        exclusive = 500,  -- 500 Robux
        clone = 10,       -- Fee for cloning
        move = 2,         -- Fee for moving
        destroy = 1,      -- Fee for destroying
        rotate = 1        -- Fee for rotating
    },

    -- Item definitions
    ITEMS = {
        basic_cube = {
            name = "Basic Cube",
            description = "A simple cube for building",
            price = 100,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "basic"
        },
        premium_cube = {
            name = "Premium Cube",
            description = "A fancy cube with special effects",
            price = 500,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "premium"
        },
        rare_cube = {
            name = "Rare Cube",
            description = "An extremely rare cube with unique properties",
            price = 1000,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "rare"
        }
    },
    
    -- UI Constants
    UI = {
        DIALOG_ANIMATION_DURATION = 0.3,
        BUTTON_HOVER_DURATION = 0.2,
        ERROR_DISPLAY_DURATION = 2
    }
}

return Constants</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">GameManager</string>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local RunService = game:GetService("RunService")

local Constants = require(script.Parent.Constants)

-- Determine if we're on the server
local IS_SERVER = RunService:IsServer()

-- Create GameManager as proper OOP class
local GameManager = {}
GameManager.__index = GameManager

function GameManager.new()
    local self = setmetatable({}, GameManager)
    
    -- Shared properties for both server and client
    self.remotes = ReplicatedStorage:WaitForChild("Remotes")
    self.constants = Constants
    
    if IS_SERVER then
        self.playerData = {}
        
        -- Initialize DataStores on server
        local DataStoreService = game:GetService("DataStoreService")
        self.PlayerCurrencyStore = DataStoreService:GetDataStore("PlayerCurrency")
        self.PlayerInventoryStore = DataStoreService:GetDataStore("PlayerInventory")
        self.PlacedItemsStore = DataStoreService:GetDataStore("PlacedItems")
    end
    
    return self
end

-- Server-only functionality
if IS_SERVER then
    local Players = game:GetService("Players")
    
    -- Helper: skip DataStore in Studio
    function GameManager:canUseDataStore()
        return not RunService:IsStudio()
    end
    
    -- Initialize player data
    function GameManager:initializePlayerData(player)
        self.playerData[player.UserId] = {
            currency = self.constants.GAME.STARTING_CURRENCY,
            inventory = {},
            placedItems = {}
        }
        
        if self:canUseDataStore() then
            local success, result = pcall(function()
                local currency = self.PlayerCurrencyStore:GetAsync(player.UserId)
                local inventory = self.PlayerInventoryStore:GetAsync(player.UserId)
                local placedItems = self.PlacedItemsStore:GetAsync(player.UserId)
                
                if currency then self.playerData[player.UserId].currency = currency end
                if inventory then self.playerData[player.UserId].inventory = inventory end
                if placedItems then self.playerData[player.UserId].placedItems = placedItems end
            end)
            
            if not success then 
                warn("Failed to load data for", player.Name, ":", result) 
            end
        end
    end
    
    -- Save player data
    function GameManager:savePlayerData(player)
        local userId = player.UserId
        if not self.playerData[userId] then return end
        
        if self:canUseDataStore() then
            local success, result = pcall(function()
                self.PlayerCurrencyStore:SetAsync(userId, self.playerData[userId].currency)
                self.PlayerInventoryStore:SetAsync(userId, self.playerData[userId].inventory)
                self.PlacedItemsStore:SetAsync(userId, self.playerData[userId].placedItems)
            end)
            
            if not success then 
                warn("Failed to save data for", player.Name, ":", result) 
            end
        end
    end
    
    -- Update client UI
    function GameManager:updateClientUI(player)
        if self.remotes.UpdateBalance then
            self.remotes.UpdateBalance:FireClient(player, self.playerData[player.UserId].currency)
        end
        -- You can add more remotes for inventory if needed
    end
    
    -- Initialize method
    function GameManager:Initialize()
        print("Initializing GameManager...")
        
        -- Player join/leave events
        Players.PlayerAdded:Connect(function(player)
            self:initializePlayerData(player)
            self:updateClientUI(player)
        end)
        
        Players.PlayerRemoving:Connect(function(player)
            self:savePlayerData(player)
            self.playerData[player.UserId] = nil
        end)
        
        print("GameManager initialized successfully")
    end
    
    -- Purchase logic
    function GameManager:HandleBuyItem(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        local itemData = self.constants.ITEMS[itemId]
        
        if not pdata or not itemData then
            return { success = false, message = "Invalid item or player." }
        end
        
        if pdata.currency &lt; itemData.price then
            return { success = false, message = "Not enough currency." }
        end
        
        pdata.currency = pdata.currency - itemData.price
        pdata.inventory[itemId] = (pdata.inventory[itemId] or 0) + 1
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Purchase successful!" }
    end
    
    -- Placement logic
    function GameManager:HandlePlaceItem(player, itemId, position, rotation)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.inventory[itemId] or pdata.inventory[itemId] &lt;= 0 then
            return { success = false, message = "You do not have this item in your inventory." }
        end
        
        -- Placement validation (stub: always true)
        local validPlacement = true -- TODO: add collision/grid checks
        if not validPlacement then
            return { success = false, message = "Invalid placement location." }
        end
        
        pdata.inventory[itemId] = pdata.inventory[itemId] - 1
        
        -- Add to placedItems
        local placedId = tostring(os.time()) .. tostring(math.random(1000,9999))
        pdata.placedItems[placedId] = { id = itemId, position = position, rotation = rotation }
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item placed successfully!" }
    end
    
    -- Remove item logic
    function GameManager:HandleRemoveItem(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot remove this item." }
        end
        
        pdata.placedItems[itemId] = nil
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item removed successfully!" }
    end
    
    -- Move/Rotate logic
    function GameManager:HandleMoveItem(player, itemId, newPosition)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot move this item." }
        end
        
        pdata.placedItems[itemId].position = newPosition
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item moved successfully!" }
    end
    
    function GameManager:HandleRotateItem(player, itemId, newRotation)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot rotate this item." }
        end
        
        pdata.placedItems[itemId].rotation = newRotation
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item rotated successfully!" }
    end
    
    function GameManager:HandleChangeColor(player, itemId, newColor)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot change the color of this item." }
        end
        
        pdata.placedItems[itemId].color = newColor
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item color changed successfully!" }
    end
    
    function GameManager:GetPlayerInventory(player)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata then
            return { success = false, message = "Player data not found." }
        end
        
        return { success = true, inventory = pdata.inventory, currency = pdata.currency }
    end
    
    function GameManager:GetItemData(itemId)
        return self.constants.ITEMS[itemId]
    end
    
    function GameManager:GetItemPlacement(itemId)
        -- This would check all players' placed items for the specified ID
        -- For simplicity, we're just returning nil for now
        for userId, pdata in pairs(self.playerData) do
            if pdata.placedItems[itemId] then
                return pdata.placedItems[itemId]
            end
        end
        return nil
    end
    
    function GameManager:AddToInventory(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata then
            return { success = false, message = "Player data not found." }
        end
        
        pdata.inventory[itemId] = (pdata.inventory[itemId] or 0) + 1
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item added to inventory!" }
    end
    
    function GameManager:ApplyItemEffect(player, itemId, placement)
        -- Implement item effect logic here
        -- For now, just return success
        return { success = true, message = "Item effect applied!" }
    end
end

-- Client-only functionality
if not IS_SERVER then
    function GameManager:Initialize()
        print("Initializing GameManager client...")
        -- Client initialization code here
        print("GameManager client initialized successfully")
    end
end

return GameManager</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">economy</string>
            <string name="Source"><![CDATA[local Economy = {}
Economy.CurrencyManager = require(script.CurrencyManager)
return Economy ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">CurrencyManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local DataStoreService = game:GetService("DataStoreService")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(script.Parent.Parent.Constants)

local CurrencyManager = {}
CurrencyManager.__index = CurrencyManager

-- Initialize a new CurrencyManager
function CurrencyManager.new()
    local self = setmetatable({}, CurrencyManager)
    self.playerBalances = {}
    self.currencyStore = DataStoreService:GetDataStore("PlayerCurrency")
    self.rewardTimers = {}
    self:Initialize()
    return self
end

-- Initialize the CurrencyManager
function CurrencyManager:Initialize()
    -- Set up player handling
    self:SetupPlayerHandling()
    
    -- Set up marketplace handling
    self:SetupMarketplaceHandling()
end

-- Set up player handling
function CurrencyManager:SetupPlayerHandling()
    game.Players.PlayerAdded:Connect(function(player)
        self:OnPlayerJoined(player)
    end)
    
    game.Players.PlayerRemoving:Connect(function(player)
        self:OnPlayerLeaving(player)
    end)
end

-- Set up marketplace handling
function CurrencyManager:SetupMarketplaceHandling()
    -- Handle purchase requests
    MarketplaceService.ProcessReceipt = function(receiptInfo)
        local player = game.Players:GetPlayerByUserId(receiptInfo.PlayerId)
        if not player then
            return Enum.ProductPurchaseDecision.NotProcessedYet
        end
        
        -- Process the purchase
        local success = self:ProcessPurchase(player, receiptInfo)
        if success then
            return Enum.ProductPurchaseDecision.PurchaseGranted
        else
            return Enum.ProductPurchaseDecision.NotProcessedYet
        end
    end
end

-- Handle player joining
function CurrencyManager:OnPlayerJoined(player)
    -- Initialize player balance
    self:InitializePlayerBalance(player)
    
    -- Start reward timer
    self:StartRewardTimer(player)
    
    -- Check for daily/weekly/monthly bonuses
    self:CheckLoginBonuses(player)
end

-- Handle player leaving
function CurrencyManager:OnPlayerLeaving(player)
    -- Stop reward timer
    self:StopRewardTimer(player)
    
    -- Save player balance
    self:SavePlayerBalance(player)
end

-- Initialize player balance
function CurrencyManager:InitializePlayerBalance(player)
    local balance = {
        coins = 0,
        lastRewardTime = os.time(),
        lastDailyBonus = 0,
        lastWeeklyBonus = 0,
        lastMonthlyBonus = 0
    }
    
    self.playerBalances[player.UserId] = balance
    
    -- Load saved balance
    self:LoadPlayerBalance(player)
end

-- Load player balance from DataStore
function CurrencyManager:LoadPlayerBalance(player)
    local success, result = pcall(function()
        return self.currencyStore:GetAsync(player.UserId)
    end)
    
    if success and result then
        self.playerBalances[player.UserId] = result
    end
end

-- Save player balance to DataStore
function CurrencyManager:SavePlayerBalance(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    pcall(function()
        self.currencyStore:SetAsync(player.UserId, balance)
    end)
end

-- Start reward timer for player
function CurrencyManager:StartRewardTimer(player)
    local timer = task.spawn(function()
        while player and player.Parent do
            task.wait(Constants.CURRENCY.REWARD_INTERVAL)
            self:GiveReward(player)
        end
    end)
    
    self.rewardTimers[player.UserId] = timer
end

-- Stop reward timer for player
function CurrencyManager:StopRewardTimer(player)
    local timer = self.rewardTimers[player.UserId]
    if timer then
        task.cancel(timer)
        self.rewardTimers[player.UserId] = nil
    end
end

-- Give reward to player
function CurrencyManager:GiveReward(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    -- Calculate reward amount
    local rewardAmount = math.floor(Constants.CURRENCY.REWARD_RATE * (Constants.CURRENCY.REWARD_INTERVAL / 60))
    rewardAmount = math.clamp(rewardAmount, Constants.CURRENCY.MIN_REWARD_AMOUNT, Constants.CURRENCY.MAX_REWARD_AMOUNT)
    
    -- Add reward to balance
    balance.coins = balance.coins + rewardAmount
    balance.lastRewardTime = os.time()
    
    -- Update player
    self:UpdatePlayerBalance(player)
end

-- Check login bonuses
function CurrencyManager:CheckLoginBonuses(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    local currentTime = os.time()
    
    -- Check daily bonus
    if currentTime - balance.lastDailyBonus >= 86400 then -- 24 hours
        balance.coins = balance.coins + Constants.CURRENCY.DAILY_BONUS
        balance.lastDailyBonus = currentTime
    end
    
    -- Check weekly bonus
    if currentTime - balance.lastWeeklyBonus >= 604800 then -- 7 days
        balance.coins = balance.coins + Constants.CURRENCY.WEEKLY_BONUS
        balance.lastWeeklyBonus = currentTime
    end
    
    -- Check monthly bonus
    if currentTime - balance.lastMonthlyBonus >= 2592000 then -- 30 days
        balance.coins = balance.coins + Constants.CURRENCY.MONTHLY_BONUS
        balance.lastMonthlyBonus = currentTime
    end
    
    -- Update player
    self:UpdatePlayerBalance(player)
end

-- Update player balance
function CurrencyManager:UpdatePlayerBalance(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    -- Update player attributes
    player:SetAttribute("Coins", balance.coins)
    
    -- Fire client event
    ReplicatedStorage.Remotes.UpdateBalance:FireClient(player, balance.coins)
end

-- Get player balance
function CurrencyManager:GetBalance(player)
    local balance = self.playerBalances[player.UserId]
    return balance and balance.coins or 0
end

-- Add coins to player
function CurrencyManager:AddCoins(player, amount)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    balance.coins = balance.coins + amount
    self:UpdatePlayerBalance(player)
    return true
end

-- Remove coins from player
function CurrencyManager:RemoveCoins(player, amount)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    if balance.coins < amount then
        return false
    end
    
    balance.coins = balance.coins - amount
    self:UpdatePlayerBalance(player)
    return true
end

-- Process Robux purchase
function CurrencyManager:ProcessPurchase(player, receiptInfo)
    -- Get product info
    local productId = receiptInfo.ProductId
    local productInfo = self:GetProductInfo(productId)
    if not productInfo then return false end
    
    -- Add coins to player
    return self:AddCoins(player, productInfo.coins)
end

-- Get product info
function CurrencyManager:GetProductInfo(productId)
    -- TODO: Implement product info lookup
    return nil
end

-- Check if player can afford item
function CurrencyManager:CanAffordItem(player, itemId, useRobux)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    -- Get item price
    local price = self:GetItemPrice(itemId, useRobux)
    if not price then return false end
    
    if useRobux then
        -- Check Robux balance
        return player:GetAttribute("Robux") >= price
    else
        -- Check coin balance
        return balance.coins >= price
    end
end

-- Get item price
function CurrencyManager:GetItemPrice(itemId, useRobux)
    -- TODO: Implement item price lookup
    return nil
end

return CurrencyManager ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">interaction</string>
            <string name="Source"><![CDATA[local Interaction = {}
Interaction.Manager = require(script.InteractionManager)
return Interaction ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="8">
            <Properties>
              <string name="Name">InteractionManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local InteractionManager = {}
InteractionManager.__index = InteractionManager

function InteractionManager.new()
    local self = setmetatable({}, InteractionManager)
    self.interactions = {}
    return self
end

function InteractionManager:Initialize()
    print("InteractionManager initialized")
    self:RegisterDefaultInteractions()
end

function InteractionManager:RegisterInteraction(itemId, interactionType, callback)
    if not self.interactions[itemId] then
        self.interactions[itemId] = {}
    end
    
    self.interactions[itemId][interactionType] = callback
end

function InteractionManager:UnregisterInteraction(itemId, interactionType)
    if self.interactions[itemId] then
        self.interactions[itemId][interactionType] = nil
    end
end

function InteractionManager:HandleInteraction(player, itemId, interactionType, ...)
    if not self.interactions[itemId] or not self.interactions[itemId][interactionType] then
        -- Try default interactions if specific ones don't exist
        if self.interactions["default"] and self.interactions["default"][interactionType] then
            return self.interactions["default"][interactionType](player, itemId, ...)
        end
        return false
    end
    
    return self.interactions[itemId][interactionType](player, ...)
end

-- Default interactions
function InteractionManager:RegisterDefaultInteractions()
    -- Pick up interaction
    self:RegisterInteraction("default", "pickup", function(player, itemId, placement)
        -- Check if player can pick up the item
        if not placement or not placement.model then return false end
        
        -- Get player's inventory
        local inventory = ReplicatedStorage.Remotes.GetInventory:InvokeServer(player)
        if not inventory then return false end
        
        -- Check if inventory has space
        if #inventory >= Constants.GAME.MAX_INVENTORY_SIZE then
            -- Notify player inventory is full
            ReplicatedStorage.Remotes.NotifyPlayer:FireClient(player, "Inventory is full!")
            return false
        end
        
        -- Remove item from world
        placement.model:Destroy()
        
        -- Add to inventory
        ReplicatedStorage.Remotes.AddToInventory:FireServer(player, itemId)
        
        return true
    end)
    
    -- Use interaction
    self:RegisterInteraction("default", "use", function(player, itemId, placement)
        -- Check if item can be used
        if not placement or not placement.model then return false end
        
        -- Get item data
        local itemData = ReplicatedStorage.Remotes.GetItemData:InvokeServer(itemId)
        if not itemData then return false end
        
        -- Check if item has use effect
        if itemData.useEffect then
            -- Apply effect
            ReplicatedStorage.Remotes.ApplyItemEffect:FireServer(player, itemId, placement)
        end
        
        return true
    end)
    
    -- Examine interaction
    self:RegisterInteraction("default", "examine", function(player, itemId, placement)
        -- Get item data
        local itemData = ReplicatedStorage.Remotes.GetItemData:InvokeServer(itemId)
        if not itemData then return false end
        
        -- Show item description
        ReplicatedStorage.Remotes.ShowItemDescription:FireClient(player, itemData.description)
        
        return true
    end)
    
    -- Custom interactions for specific items
    self:RegisterInteraction("glow_cube", "change_color", function(player, itemId, placement)
        if not placement or not placement.model then return false end
        
        -- Get current color
        local currentColor = placement.model:GetAttribute("Color") or "White"
        
        -- Get next color
        local colors = {"Red", "Green", "Blue", "Yellow", "Purple", "White"}
        local currentIndex = table.find(colors, currentColor) or 1
        local nextIndex = (currentIndex % #colors) + 1
        local newColor = colors[nextIndex]
        
        -- Update color
        placement.model:SetAttribute("Color", newColor)
        
        -- Update visual
        for _, part in ipairs(placement.model:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Color = Constants.UI_COLORS[newColor:upper()]
            end
        end
        
        return true
    end)
end

return InteractionManager ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">inventory</string>
            <string name="Source"><![CDATA[local Inventory = {}
Inventory.Manager = require(script.InventoryManager)
Inventory.ItemManager = require(script.ItemManager)
return Inventory ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">InventoryManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local InventoryManager = {}
InventoryManager.__index = InventoryManager

function InventoryManager.new()
    local self = setmetatable({}, InventoryManager)
    self.playerInventories = {}
    return self
end

function InventoryManager:Initialize()
    print("InventoryManager initialized")
end

function InventoryManager:InitializePlayer(player)
    self.playerInventories[player.UserId] = {
        items = {},
        maxSlots = Constants.GAME.MAX_INVENTORY_SLOTS
    }
end

function InventoryManager:CleanupPlayer(player)
    self.playerInventories[player.UserId] = nil
end

function InventoryManager:GetInventory(player)
    return self.playerInventories[player.UserId]
end

function InventoryManager:AddItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    if #inventory.items >= inventory.maxSlots then
        return false
    end
    
    table.insert(inventory.items, {
        id = itemId,
        quantity = quantity
    })
    
    return true
end

function InventoryManager:RemoveItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    for i, item in ipairs(inventory.items) do
        if item.id == itemId then
            if item.quantity > quantity then
                item.quantity = item.quantity - quantity
            else
                table.remove(inventory.items, i)
            end
            return true
        end
    end
    
    return false
end

function InventoryManager:HasItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    for _, item in ipairs(inventory.items) do
        if item.id == itemId and item.quantity >= quantity then
            return true
        end
    end
    
    return false
end

return InventoryManager
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="11">
            <Properties>
              <string name="Name">ItemManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Constants = require(script.Parent.Parent.Constants)

local ItemManager = {}
ItemManager.__index = ItemManager

function ItemManager.new()
    local self = setmetatable({}, ItemManager)
    self.items = {}
    self.categories = {}
    self.properties = {}
    self.tiers = {}
    self.tierAssignments = {}
    self.interactions = {}
    self.adminUsers = {} -- List of user IDs that are admins
    return self
end

function ItemManager:Initialize()
    print("Initializing ItemManager...")
    local success = self:LoadItems()
    if success then
        print("ItemManager successfully loaded " .. #self.items .. " items")
    else
        warn("ItemManager failed to load items properly, using fallback data")
    end
end

function ItemManager:LoadItems()
    -- We'll use hardcoded items to avoid dependency on Structure.txt
    print("Loading default items...")
    self:LoadDefaultItems()
    return true
end

function ItemManager:LoadDefaultItems()
    print("Using default item definitions")
    self.items = {
        {
            id = "brick_cube",
            name = "Brick Cube",
            price = 100,
            model = nil
        },
        {
            id = "wood_cube",
            name = "Wood Cube",
            price = 150,
            model = nil
        },
        {
            id = "stone_cube",
            name = "Stone Cube",
            price = 175,
            model = nil
        },
        {
            id = "glass_cube",
            name = "Glass Cube",
            price = 200,
            model = nil
        },
        {
            id = "glow_red_cube",
            name = "Red Glowing Cube",
            price = 300,
            model = nil
        },
        {
            id = "trampoline",
            name = "Trampoline",
            price = 750,
            model = nil
        }
    }
    
    -- Setup minimal categories
    self.categories = {
        basic = {"brick_cube", "wood_cube", "stone_cube", "glass_cube"},
        glow = {"glow_red_cube"},
        interactive = {"trampoline"}
    }
    
    -- Setup some basic interactions
    self.interactions = {
        trampoline = {"jump", "examine"}
    }
    
    return true
end

function ItemManager:IsAdmin(player)
    return self.adminUsers[player.UserId] == true
end

function ItemManager:IsItemFree(itemId, player)
    -- Use the new pricing logic
    local price = self:GetActionPrice(itemId, Constants.ITEM_ACTIONS.BUY, player)
    return price == 0
end

function ItemManager:GetActionPrice(itemId, action, player)
    -- First check tier-based pricing
    for tierName, items in pairs(self.tierAssignments) do
        for _, id in ipairs(items) do
            if id == itemId then
                return self.tiers[tierName] or 0
            end
        end
    end
    
    -- Look for the item model in Workspace > Items
    local itemsFolder = workspace:FindFirstChild("Items")
    if itemsFolder then
        for _, model in ipairs(itemsFolder:GetChildren()) do
            if model:IsA("Model") and model:GetAttribute("item") and model.Name == itemId then
                local tier = model:GetAttribute("item")
                local price = Constants.ITEM_PRICING[tier]
                if price then
                    return price
                end
            end
        end
    end
    
    -- Fallback to item's direct price
    local item = self:GetItemData(itemId)
    return item and item.price or 0
end

function ItemManager:GetItemData(itemId)
    for _, item in ipairs(self.items) do
        if item.id == itemId then
            return item
        end
    end
    return nil
end

function ItemManager:GetItemModel(itemId)
    local item = self:GetItemData(itemId)
    return item and item.model
end

function ItemManager:GetItemsByCategory(categoryName)
    local category = self.categories[categoryName]
    if not category then
        return {}
    end
    
    local items = {}
    for _, itemId in ipairs(category) do
        local item = self:GetItemData(itemId)
        if item then
            table.insert(items, item)
        end
    end
    
    return items
end

function ItemManager:GetItemInteractions(itemId)
    return self.interactions[itemId] or {"examine"}
end

function ItemManager:GetAllCategories()
    local result = {}
    for categoryName, _ in pairs(self.categories) do
        table.insert(result, categoryName)
    end
    return result
end

return ItemManager
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">placement</string>
            <string name="Source"><![CDATA[local Placement = {}
Placement.Manager = require(script.PlacementManager)
return Placement ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="13">
            <Properties>
              <string name="Name">PlacementManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local PlacementManager = {}
PlacementManager.__index = PlacementManager

function PlacementManager.new()
    local self = setmetatable({}, PlacementManager)
    self.placements = {}
    self.lastPlacementTime = {}
    self.interactionManager = nil
    return self
end

function PlacementManager:Initialize()
    print("PlacementManager initialized")
    
    -- Initialize interaction manager
    self.interactionManager = require(script.Parent.Parent.interaction.InteractionManager).new()
    self.interactionManager:Initialize()
    self.interactionManager:RegisterDefaultInteractions()
end

function PlacementManager:PlaceItem(player, itemId, position, rotation)
    -- Check cooldown
    if not self:CheckPlacementCooldown(player) then
        return false
    end
    
    -- Create placement
    local placement = {
        id = itemId,
        position = position,
        rotation = rotation,
        owner = player.UserId,
        model = nil, -- TODO: Create actual model
        interactions = {
            enabled = true,
            types = {"pickup", "use", "examine"}
        }
    }
    
    -- Add to placements
    table.insert(self.placements, placement)
    
    -- Update last placement time
    self.lastPlacementTime[player.UserId] = os.time()
    
    return true
end

function PlacementManager:MoveItem(player, placedItem, newPosition)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update position
    placement.position = newPosition
    
    return true
end

function PlacementManager:RotateItem(player, placedItem, newRotation)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update rotation
    placement.rotation = newRotation
    
    return true
end

function PlacementManager:ChangeItemColor(player, placedItem, newColor)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update color
    placement.color = newColor
    
    return true
end

function PlacementManager:RemoveItem(player, placedItem)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Remove placement
    for i, p in ipairs(self.placements) do
        if p == placement then
            table.remove(self.placements, i)
            break
        end
    end
    
    return true
end

function PlacementManager:FindPlacement(placedItem)
    for _, placement in ipairs(self.placements) do
        if placement == placedItem then
            return placement
        end
    end
    return nil
end

function PlacementManager:CheckPlacementCooldown(player)
    local lastTime = self.lastPlacementTime[player.UserId]
    if not lastTime then return true end
    
    return os.time() - lastTime >= Constants.GAME.PLACEMENT_COOLDOWN
end

-- Interaction methods
function PlacementManager:EnableInteractions(placedItem)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    placement.interactions.enabled = true
    return true
end

function PlacementManager:DisableInteractions(placedItem)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    placement.interactions.enabled = false
    return true
end

function PlacementManager:AddInteractionType(placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    if not table.find(placement.interactions.types, interactionType) then
        table.insert(placement.interactions.types, interactionType)
    end
    
    return true
end

function PlacementManager:RemoveInteractionType(placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    for i, type in ipairs(placement.interactions.types) do
        if type == interactionType then
            table.remove(placement.interactions.types, i)
            break
        end
    end
    
    return true
end

function PlacementManager:HandleInteraction(player, placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check if interactions are enabled
    if not placement.interactions.enabled then return false end
    
    -- Check if interaction type is allowed
    if not table.find(placement.interactions.types, interactionType) then return false end
    
    -- Handle the interaction
    return self.interactionManager:HandleInteraction(player, placement.id, interactionType, placement)
end

return PlacementManager
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">ui</string>
            <string name="Source"><![CDATA[local UI = {}
UI.PurchaseDialog = require(script.PurchaseDialog)
UI.InventoryUI = require(script.InventoryUI)
UI.CurrencyUI = require(script.CurrencyUI)
UI.PlacedItemDialog = require(script.PlacedItemDialog)
return UI ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="15">
            <Properties>
              <string name="Name">CurrencyUI</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(script.Parent.Parent.Parent.core.Constants)

local CurrencyUI = {}
CurrencyUI.__index = CurrencyUI

-- Initialize a new CurrencyUI
function CurrencyUI.new()
    local self = setmetatable({}, CurrencyUI)
    self.ui = nil
    return self
end

-- Initialize the CurrencyUI
function CurrencyUI:Initialize()
    -- Create UI
    self:CreateUI()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Initial balance update
    self:UpdateBalance(Constants.CURRENCY.STARTING_COINS)
end

-- Create UI
function CurrencyUI:CreateUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CurrencyUI"
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    -- Create main frame
    local frame = Instance.new("Frame")
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(0, 200, 0, 50)
    frame.Position = UDim2.new(1, -220, 0, 20)
    frame.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    -- Create coin icon
    local coinIcon = Instance.new("ImageLabel")
    coinIcon.Name = "CoinIcon"
    coinIcon.Size = UDim2.new(0, 30, 0, 30)
    coinIcon.Position = UDim2.new(0, 10, 0.5, -15)
    coinIcon.BackgroundTransparency = 1
    coinIcon.Image = "rbxassetid://101567167458494" -- TODO: Add coin icon
    coinIcon.Parent = frame
    
    -- Create balance label
    local balanceLabel = Instance.new("TextLabel")
    balanceLabel.Name = "BalanceLabel"
    balanceLabel.Size = UDim2.new(0, 100, 1, 0)
    balanceLabel.Position = UDim2.new(0, 50, 0, 0)
    balanceLabel.BackgroundTransparency = 1
    balanceLabel.TextColor3 = Constants.UI_COLORS.TEXT
    balanceLabel.TextSize = 18
    balanceLabel.Font = Enum.Font.GothamBold
    balanceLabel.Text = "0"
    balanceLabel.Parent = frame
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0, 30, 0, 30)
    purchaseButton.Position = UDim2.new(1, -40, 0.5, -15)
    purchaseButton.BackgroundColor3 = Constants.UI_COLORS.PRIMARY
    purchaseButton.Text = "+"
    purchaseButton.TextColor3 = Constants.UI_COLORS.TEXT
    purchaseButton.TextSize = 20
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Parent = frame
    
    self.ui = screenGui
end

-- Set up event handlers
function CurrencyUI:SetupEventHandlers()
    -- Handle balance updates
    ReplicatedStorage.Remotes.UpdateBalance.OnClientEvent:Connect(function(balance)
        self:UpdateBalance(balance)
    end)
    
    -- Handle purchase button click
    self.ui.MainFrame.PurchaseButton.MouseButton1Click:Connect(function()
        self:ShowPurchaseMenu()
    end)
end

-- Update balance display
function CurrencyUI:UpdateBalance(balance)
    self.ui.MainFrame.BalanceLabel.Text = tostring(balance)
end

-- Show purchase menu
function CurrencyUI:ShowPurchaseMenu()
    -- Create purchase menu
    local menu = Instance.new("Frame")
    menu.Name = "PurchaseMenu"
    menu.Size = UDim2.new(0, 300, 0, 400)
    menu.Position = UDim2.new(0.5, -150, 0.5, -200)
    menu.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    menu.BorderSizePixel = 0
    menu.Parent = self.ui
    
    -- Create close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Constants.UI_COLORS.ERROR
    closeButton.Text = "X"
    closeButton.TextColor3 = Constants.UI_COLORS.TEXT
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = menu
    
    -- Create purchase options
    local yOffset = 50
    for _, product in ipairs(Constants.CURRENCY.PRODUCTS) do
        local option = Instance.new("TextButton")
        option.Name = "Option_" .. product.id
        option.Size = UDim2.new(0, 260, 0, 60)
        option.Position = UDim2.new(0.5, -130, 0, yOffset)
        option.BackgroundColor3 = Constants.UI_COLORS.PRIMARY
        option.Text = string.format("%d Coins - %d Robux", product.coins, product.robux)
        option.TextColor3 = Constants.UI_COLORS.TEXT
        option.TextSize = 18
        option.Font = Enum.Font.GothamBold
        option.Parent = menu
        
        option.MouseButton1Click:Connect(function()
            MarketplaceService:PromptProductPurchase(Players.LocalPlayer, product.id)
        end)
        
        yOffset = yOffset + 70
    end
    
    -- Handle close button
    closeButton.MouseButton1Click:Connect(function()
        menu:Destroy()
    end)
end

return CurrencyUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="16">
            <Properties>
              <string name="Name">InventoryUI</string>
              <string name="Source"><![CDATA[-- InventoryUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local InventoryUI = {}

-- UI Constants
local INVENTORY_SIZE = UDim2.new(0, 600, 0, 400)
local INVENTORY_POSITION = UDim2.new(0.5, -300, 0.5, -200)
local ANIMATION_DURATION = 0.3
local ITEM_SIZE = UDim2.new(0, 100, 0, 120)
local ITEMS_PER_ROW = 5
local ITEM_PADDING = 10

-- Create the inventory UI
local function createInventory(parent)
    local inventory = Instance.new("Frame")
    inventory.Name = "InventoryUI"
    inventory.Size = INVENTORY_SIZE
    inventory.Position = INVENTORY_POSITION
    inventory.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    inventory.BorderSizePixel = 0
    inventory.Visible = false
    inventory.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = inventory
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = inventory
    
    -- Title bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 50)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = inventory
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleBar
    
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.new(0, 20, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.Text = "Inventory"
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar
    
    local currency = Instance.new("TextLabel")
    currency.Name = "Currency"
    currency.Size = UDim2.new(0, 100, 1, 0)
    currency.Position = UDim2.new(1, -120, 0, 0)
    currency.BackgroundTransparency = 1
    currency.Font = Enum.Font.GothamBold
    currency.Text = "0"
    currency.TextSize = 20
    currency.TextColor3 = Color3.fromRGB(255, 215, 0)
    currency.TextXAlignment = Enum.TextXAlignment.Right
    currency.Parent = titleBar
    
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.TextSize = 18
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Parent = titleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton
    
    -- Items container
    local itemsContainer = Instance.new("ScrollingFrame")
    itemsContainer.Name = "ItemsContainer"
    itemsContainer.Size = UDim2.new(1, -40, 1, -70)
    itemsContainer.Position = UDim2.new(0, 20, 0, 60)
    itemsContainer.BackgroundTransparency = 1
    itemsContainer.BorderSizePixel = 0
    itemsContainer.ScrollBarThickness = 6
    itemsContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    itemsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    itemsContainer.Parent = inventory
    
    -- Create grid layout
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = ITEM_SIZE
    gridLayout.CellPadding = UDim2.new(0, ITEM_PADDING, 0, ITEM_PADDING)
    gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    gridLayout.Parent = itemsContainer
    
    return inventory
end

-- Create an item button
local function createItemButton(itemName, itemData, quantity)
    local button = Instance.new("TextButton")
    button.Name = itemName
    button.Size = ITEM_SIZE
    button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    button.AutoButtonColor = false
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    -- Item icon (placeholder)
    local icon = Instance.new("ImageLabel")
    icon.Name = "Icon"
    icon.Size = UDim2.new(1, -20, 0, 60)
    icon.Position = UDim2.new(0, 10, 0, 10)
    icon.BackgroundTransparency = 1
    icon.Image = itemData.icon or "rbxassetid://0" -- Replace with actual icon
    icon.Parent = button
    
    -- Item name
    local name = Instance.new("TextLabel")
    name.Name = "Name"
    name.Size = UDim2.new(1, -20, 0, 20)
    name.Position = UDim2.new(0, 10, 0, 80)
    name.BackgroundTransparency = 1
    name.Font = Enum.Font.GothamBold
    name.Text = itemName
    name.TextSize = 14
    name.TextColor3 = Color3.new(1, 1, 1)
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.Parent = button
    
    -- Quantity
    local quantityLabel = Instance.new("TextLabel")
    quantityLabel.Name = "Quantity"
    quantityLabel.Size = UDim2.new(1, -20, 0, 20)
    quantityLabel.Position = UDim2.new(0, 10, 0, 100)
    quantityLabel.BackgroundTransparency = 1
    quantityLabel.Font = Enum.Font.Gotham
    quantityLabel.Text = "x" .. quantity
    quantityLabel.TextSize = 14
    quantityLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    quantityLabel.Parent = button
    
    -- Hover effect
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        }):Play()
    end)
    
    return button
end

-- Initialize the inventory UI
function InventoryUI.Initialize(parent)
    local inventory = createInventory(parent)
    
    -- Set up close button
    inventory.TitleBar.CloseButton.MouseButton1Click:Connect(function()
        InventoryUI.Hide()
    end)
    
    -- Store inventory reference
    InventoryUI._inventory = inventory
end

-- Update inventory display
function InventoryUI.UpdateInventory(inventory, currency)
    local ui = InventoryUI._inventory
    if not ui then return end
    
    -- Update currency
    ui.TitleBar.Currency.Text = tostring(currency or 0)
    
    -- Clear existing items
    local container = ui.ItemsContainer
    for _, child in ipairs(container:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end
    
    -- Add items
    local itemCount = 0
    for itemName, quantity in pairs(inventory) do
        if quantity > 0 then
            local itemData = Constants.ITEMS[itemName]
            if itemData then
                local button = createItemButton(itemName, itemData, quantity)
                button.Parent = container
                
                -- Set up click handler
                button.MouseButton1Click:Connect(function()
                    if InventoryUI.OnItemSelected then
                        InventoryUI.OnItemSelected(itemName)
                    end
                end)
                
                itemCount = itemCount + 1
            end
        end
    end
    
    -- Update canvas size
    local rows = math.ceil(itemCount / ITEMS_PER_ROW)
    container.CanvasSize = UDim2.new(0, 0, 0, rows * (ITEM_SIZE.Y.Offset + ITEM_PADDING) + ITEM_PADDING)
end

-- Show the inventory
function InventoryUI.Show()
    local inventory = InventoryUI._inventory
    if not inventory then return end
    
    inventory.Visible = true
    inventory.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(inventory, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the inventory
function InventoryUI.Hide()
    local inventory = InventoryUI._inventory
    if not inventory then return end
    
    local hideTween = TweenService:Create(inventory, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        inventory.Visible = false
    end)
    
    hideTween:Play()
end

return InventoryUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">PlacedItemDialog</string>
              <string name="Source"><![CDATA[-- PlacedItemDialog.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local PlacedItemDialog = {}

-- UI Constants
local DIALOG_SIZE = UDim2.new(0, 300, 0, 400)
local DIALOG_POSITION = UDim2.new(0.5, -150, 0.5, -200)
local ANIMATION_DURATION = 0.3
local BUTTON_HEIGHT = 50
local BUTTON_PADDING = 10

-- Create the dialog UI
local function createDialog(parent)
    local dialog = Instance.new("Frame")
    dialog.Name = "PlacedItemDialog"
    dialog.Size = DIALOG_SIZE
    dialog.Position = DIALOG_POSITION
    dialog.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    dialog.BorderSizePixel = 0
    dialog.Visible = false
    dialog.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = dialog
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = dialog
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 50)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    title.BorderSizePixel = 0
    title.Font = Enum.Font.GothamBold
    title.Text = "Item Actions"
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Parent = dialog
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = title
    
    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.TextSize = 18
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Parent = title
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton
    
    -- Actions container
    local actionsContainer = Instance.new("Frame")
    actionsContainer.Name = "ActionsContainer"
    actionsContainer.Size = UDim2.new(1, -40, 1, -70)
    actionsContainer.Position = UDim2.new(0, 20, 0, 60)
    actionsContainer.BackgroundTransparency = 1
    actionsContainer.Parent = dialog
    
    -- Create action buttons
    local actions = {
        { name = "Clone", color = Color3.fromRGB(0, 120, 0), cost = Constants.ITEM_ACTIONS.clone.cost },
        { name = "Move", color = Color3.fromRGB(0, 120, 200), cost = Constants.ITEM_ACTIONS.move.cost },
        { name = "Rotate", color = Color3.fromRGB(200, 120, 0), cost = Constants.ITEM_ACTIONS.rotate.cost },
        { name = "Destroy", color = Color3.fromRGB(200, 0, 0), cost = Constants.ITEM_ACTIONS.destroy.cost }
    }
    
    for i, action in ipairs(actions) do
        local button = Instance.new("TextButton")
        button.Name = action.name
        button.Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT)
        button.Position = UDim2.new(0, 0, 0, (i-1) * (BUTTON_HEIGHT + BUTTON_PADDING))
        button.BackgroundColor3 = action.color
        button.Font = Enum.Font.GothamBold
        button.Text = string.format("%s (%d)", action.name, action.cost)
        button.TextSize = 18
        button.TextColor3 = Color3.new(1, 1, 1)
        button.Parent = actionsContainer
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 4)
        buttonCorner.Parent = button
        
        -- Hover effect
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = action.color:Lerp(Color3.new(1, 1, 1), 0.2)
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = action.color
            }):Play()
        end)
    end
    
    return dialog
end

-- Initialize the dialog
function PlacedItemDialog.Initialize(parent)
    local dialog = createDialog(parent)
    local currentItemId = nil
    
    -- Set up close button
    dialog.Title.CloseButton.MouseButton1Click:Connect(function()
        PlacedItemDialog.Hide()
    end)
    
    -- Set up action buttons
    for _, button in ipairs(dialog.ActionsContainer:GetChildren()) do
        if button:IsA("TextButton") then
            button.MouseButton1Click:Connect(function()
                if PlacedItemDialog.OnActionSelected and currentItemId then
                    PlacedItemDialog.OnActionSelected(currentItemId, button.Name:lower())
                end
                PlacedItemDialog.Hide()
            end)
        end
    end
    
    -- Store dialog reference
    PlacedItemDialog._dialog = dialog
end

-- Show the dialog
function PlacedItemDialog.Show(itemId, itemName)
    local dialog = PlacedItemDialog._dialog
    if not dialog then return end
    
    currentItemId = itemId
    dialog.Title.Text = itemName or "Item Actions"
    
    -- Show dialog with animation
    dialog.Visible = true
    dialog.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the dialog
function PlacedItemDialog.Hide()
    local dialog = PlacedItemDialog._dialog
    if not dialog then return end
    
    local hideTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        dialog.Visible = false
    end)
    
    hideTween:Play()
end

return PlacedItemDialog ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="18">
            <Properties>
              <string name="Name">PurchaseDialog</string>
              <string name="Source"><![CDATA[-- PurchaseDialog.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local PurchaseDialog = {}

-- UI Constants
local DIALOG_SIZE = UDim2.new(0, 400, 0, 300)
local DIALOG_POSITION = UDim2.new(0.5, -200, 0.5, -150)
local ANIMATION_DURATION = 0.3

-- Create the dialog UI
local function createDialog(parent)
    local dialog = Instance.new("Frame")
    dialog.Name = "PurchaseDialog"
    dialog.Size = DIALOG_SIZE
    dialog.Position = DIALOG_POSITION
    dialog.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    dialog.BorderSizePixel = 0
    dialog.Visible = false
    dialog.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = dialog
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = dialog
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Parent = dialog
    
    -- Item info
    local itemInfo = Instance.new("TextLabel")
    itemInfo.Name = "ItemInfo"
    itemInfo.Size = UDim2.new(1, -40, 0, 60)
    itemInfo.Position = UDim2.new(0, 20, 0, 50)
    itemInfo.BackgroundTransparency = 1
    itemInfo.Font = Enum.Font.Gotham
    itemInfo.TextSize = 16
    itemInfo.TextColor3 = Color3.fromRGB(200, 200, 200)
    itemInfo.TextWrapped = true
    itemInfo.Parent = dialog
    
    -- Price
    local price = Instance.new("TextLabel")
    price.Name = "Price"
    price.Size = UDim2.new(1, -40, 0, 30)
    price.Position = UDim2.new(0, 20, 0, 120)
    price.BackgroundTransparency = 1
    price.Font = Enum.Font.GothamBold
    price.TextSize = 20
    price.TextColor3 = Color3.fromRGB(255, 215, 0)
    price.Parent = dialog
    
    -- Quantity selector
    local quantityFrame = Instance.new("Frame")
    quantityFrame.Name = "QuantityFrame"
    quantityFrame.Size = UDim2.new(1, -40, 0, 40)
    quantityFrame.Position = UDim2.new(0, 20, 0, 160)
    quantityFrame.BackgroundTransparency = 1
    quantityFrame.Parent = dialog
    
    local minusButton = Instance.new("TextButton")
    minusButton.Name = "MinusButton"
    minusButton.Size = UDim2.new(0, 40, 1, 0)
    minusButton.Position = UDim2.new(0, 0, 0, 0)
    minusButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    minusButton.Font = Enum.Font.GothamBold
    minusButton.Text = "-"
    minusButton.TextSize = 24
    minusButton.TextColor3 = Color3.new(1, 1, 1)
    minusButton.Parent = quantityFrame
    
    local quantityLabel = Instance.new("TextLabel")
    quantityLabel.Name = "Quantity"
    quantityLabel.Size = UDim2.new(1, -80, 1, 0)
    quantityLabel.Position = UDim2.new(0, 40, 0, 0)
    quantityLabel.BackgroundTransparency = 1
    quantityLabel.Font = Enum.Font.GothamBold
    quantityLabel.Text = "1"
    quantityLabel.TextSize = 20
    quantityLabel.TextColor3 = Color3.new(1, 1, 1)
    quantityLabel.Parent = quantityFrame
    
    local plusButton = Instance.new("TextButton")
    plusButton.Name = "PlusButton"
    plusButton.Size = UDim2.new(0, 40, 1, 0)
    plusButton.Position = UDim2.new(1, -40, 0, 0)
    plusButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    plusButton.Font = Enum.Font.GothamBold
    plusButton.Text = "+"
    plusButton.TextSize = 24
    plusButton.TextColor3 = Color3.new(1, 1, 1)
    plusButton.Parent = quantityFrame
    
    -- Add corner radius to buttons
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = minusButton
    
    local plusButtonCorner = buttonCorner:Clone()
    plusButtonCorner.Parent = plusButton
    
    -- Buttons
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Name = "ButtonFrame"
    buttonFrame.Size = UDim2.new(1, -40, 0, 40)
    buttonFrame.Position = UDim2.new(0, 20, 1, -60)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = dialog
    
    local cancelButton = Instance.new("TextButton")
    cancelButton.Name = "CancelButton"
    cancelButton.Size = UDim2.new(0.5, -10, 1, 0)
    cancelButton.Position = UDim2.new(0, 0, 0, 0)
    cancelButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    cancelButton.Font = Enum.Font.GothamBold
    cancelButton.Text = "Cancel"
    cancelButton.TextSize = 18
    cancelButton.TextColor3 = Color3.new(1, 1, 1)
    cancelButton.Parent = buttonFrame
    
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0.5, -10, 1, 0)
    purchaseButton.Position = UDim2.new(0.5, 10, 0, 0)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 120, 0)
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Text = "Purchase"
    purchaseButton.TextSize = 18
    purchaseButton.TextColor3 = Color3.new(1, 1, 1)
    purchaseButton.Parent = buttonFrame
    
    -- Add corner radius to buttons
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = cancelButton
    
    local purchaseButtonCorner = buttonCorner:Clone()
    purchaseButtonCorner.Parent = purchaseButton
    
    return dialog
end

-- Initialize the dialog
function PurchaseDialog.Initialize(parent)
    local dialog = createDialog(parent)
    local quantity = 1
    local currentItem = nil
    local onPurchase = nil
    
    -- Update price display
    local function updatePrice()
        if not currentItem then return end
        local itemData = Constants.ITEMS[currentItem]
        if not itemData then return end
        
        local totalPrice = itemData.price * quantity
        dialog.Price.Text = string.format("Price: %d", totalPrice)
    end
    
    -- Update quantity
    local function updateQuantity(newQuantity)
        quantity = math.max(1, math.min(99, newQuantity))
        dialog.QuantityFrame.Quantity.Text = tostring(quantity)
        updatePrice()
    end
    
    -- Set up quantity buttons
    dialog.QuantityFrame.MinusButton.MouseButton1Click:Connect(function()
        updateQuantity(quantity - 1)
    end)
    
    dialog.QuantityFrame.PlusButton.MouseButton1Click:Connect(function()
        updateQuantity(quantity + 1)
    end)
    
    -- Set up purchase button
    dialog.ButtonFrame.PurchaseButton.MouseButton1Click:Connect(function()
        if onPurchase then
            onPurchase(quantity)
        end
        PurchaseDialog.Hide()
    end)
    
    -- Set up cancel button
    dialog.ButtonFrame.CancelButton.MouseButton1Click:Connect(function()
        PurchaseDialog.Hide()
    end)
    
    -- Store dialog reference
    PurchaseDialog._dialog = dialog
end

-- Show the dialog
function PurchaseDialog.Show(itemName, callback)
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    local itemData = Constants.ITEMS[itemName]
    if not itemData then return end
    
    -- Update dialog content
    dialog.Title.Text = itemName
    dialog.ItemInfo.Text = itemData.description or "No description available"
    currentItem = itemName
    onPurchase = callback
    
    -- Reset quantity
    updateQuantity(1)
    
    -- Show dialog with animation
    dialog.Visible = true
    dialog.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the dialog
function PurchaseDialog.Hide()
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    local hideTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        dialog.Visible = false
    end)
    
    hideTween:Play()
end

-- Show error message
function PurchaseDialog.ShowError(message)
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    dialog.ItemInfo.Text = "Error: " .. message
    dialog.ItemInfo.TextColor3 = Color3.fromRGB(255, 100, 100)
    
    -- Reset color after 2 seconds
    task.delay(2, function()
        if dialog.ItemInfo then
            dialog.ItemInfo.TextColor3 = Color3.fromRGB(200, 200, 200)
        end
    end)
end

return PurchaseDialog ]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="19">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="20">
      <Properties>
        <string name="Name">server</string>
        <token name="RunContext">0</token>
        <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local SharedModule = require(ReplicatedStorage.shared)
local GameManagerModule = SharedModule.GameManager
local CurrencyManagerModule = SharedModule.Economy.CurrencyManager
local InteractionManagerModule = SharedModule.Interaction.Manager

-- Create manager instances with consistent approach
local gameManager = GameManagerModule.new()
local currencyManager = CurrencyManagerModule.new()
local interactionManager = InteractionManagerModule.new()

-- Initialize all managers
gameManager:Initialize()
currencyManager:Initialize()
interactionManager:Initialize()

-- Create Remotes folder if it doesn't exist
if not ReplicatedStorage:FindFirstChild("Remotes") then
    local remotes = Instance.new("Folder")
    remotes.Name = "Remotes"
    remotes.Parent = ReplicatedStorage
end

-- Create remote events and functions
local remotes = ReplicatedStorage.Remotes
local events = {
    "BuyItem",
    "PlaceItem",
    "MoveItem",
    "RotateItem",
    "ChangeColor",
    "RemoveItem",
    "InteractWithItem",
    "AddToInventory",
    "ApplyItemEffect",
    "ShowItemDescription",
    "NotifyPlayer",
    "UpdateBalance"
}

local functions = {
    "GetInventory",
    "GetItemData",
    "GetAvailableInteractions"
}

-- Create RemoteEvents
for _, eventName in ipairs(events) do
    if not remotes:FindFirstChild(eventName) then
        local event = Instance.new("RemoteEvent")
        event.Name = eventName
        event.Parent = remotes
    end
end

-- Create RemoteFunctions
for _, functionName in ipairs(functions) do
    if not remotes:FindFirstChild(functionName) then
        local func = Instance.new("RemoteFunction")
        func.Name = functionName
        func.Parent = remotes
    end
end

-- Setup event handlers
remotes.BuyItem.OnServerEvent:Connect(function(player, itemId)
    gameManager:HandleBuyItem(player, itemId)
end)

remotes.PlaceItem.OnServerEvent:Connect(function(player, itemId, position, rotation)
    gameManager:HandlePlaceItem(player, itemId, position, rotation)
end)

remotes.MoveItem.OnServerEvent:Connect(function(player, itemId, newPosition)
    gameManager:HandleMoveItem(player, itemId, newPosition)
end)

remotes.RotateItem.OnServerEvent:Connect(function(player, itemId, newRotation)
    gameManager:HandleRotateItem(player, itemId, newRotation)
end)

remotes.ChangeColor.OnServerEvent:Connect(function(player, itemId, newColor)
    gameManager:HandleChangeColor(player, itemId, newColor)
end)

remotes.RemoveItem.OnServerEvent:Connect(function(player, itemId)
    gameManager:HandleRemoveItem(player, itemId)
end)

remotes.GetInventory.OnServerInvoke = function(player)
    return gameManager:GetPlayerInventory(player)
end

remotes.GetItemData.OnServerInvoke = function(player, itemId)
    return gameManager:GetItemData(itemId)
end

remotes.InteractWithItem.OnServerEvent:Connect(function(player, placedItem, interactionType)
    local placement = gameManager:GetItemPlacement(placedItem.id)
    if not placement then return end
    local success = interactionManager:HandleInteraction(player, placedItem.id, interactionType, placement)
    if not success and remotes.NotifyPlayer then
        remotes.NotifyPlayer:FireClient(player, "Cannot interact with this item!")
    end
end)

remotes.GetAvailableInteractions.OnServerInvoke = function(player, placedItem)
    local placement = gameManager:GetItemPlacement(placedItem.id)
    if not placement then return {} end
    local itemData = gameManager:GetItemData(placedItem.id)
    if not itemData then return {} end
    local interactions = {"examine"}
    if not placement.locked then
        table.insert(interactions, "pickup")
    end
    if itemData.useEffect then
        table.insert(interactions, "use")
    end
    if itemData.customInteractions then
        for _, interaction in ipairs(itemData.customInteractions) do
            table.insert(interactions, interaction)
        end
    end
    return interactions
end

remotes.AddToInventory.OnServerEvent:Connect(function(player, itemId)
    gameManager:AddToInventory(player, itemId)
end)

remotes.ApplyItemEffect.OnServerEvent:Connect(function(player, itemId, placement)
    gameManager:ApplyItemEffect(player, itemId, placement)
end)

print("Server initialized successfully")</string>
      </Properties>
      <Item class="Folder" referent="21">
        <Properties>
          <string name="Name">Neon</string>
        </Properties>
        <Item class="Script" referent="22">
          <Properties>
            <string name="Name">NeonGlowManager</string>
            <token name="RunContext">0</token>
            <string name="Source">-- EnhancedGlowManager.lua
-- Place this in ServerScriptService

local TweenService = game:GetService("TweenService")
wait(1) -- Wait for everything to load

print("=== Enhanced Glow Manager Starting ===")

-- Color definitions
local GLOW_COLORS = {
	Red = Color3.fromRGB(255, 0, 0),
	Blue = Color3.fromRGB(0, 0, 255),
	Green = Color3.fromRGB(0, 255, 0),
	Purple = Color3.fromRGB(147, 39, 212),
	Yellow = Color3.fromRGB(255, 255, 0),
	Cyan = Color3.fromRGB(0, 255, 255),
	White = Color3.fromRGB(255, 255, 255),
	Orange = Color3.fromRGB(255, 128, 0)
}

-- Animation settings
local GLOW_TWEEN_INFO = TweenInfo.new(
	2,                      -- Duration
	Enum.EasingStyle.Sine,   -- Easing Style
	Enum.EasingDirection.InOut, -- Easing Direction
	-1,                     -- Repeat count (-1 = forever)
	true                    -- Reverse
)

-- Store tweens for cleanup
local activeTweens = {}

-- Recursively search through all containers
local function findAllGlowModels(parent)
	local glowModels = {}

	for _, child in ipairs(parent:GetChildren()) do
		if child:IsA("Model") and child:GetAttribute("GlowColor") then
			table.insert(glowModels, child)
		elseif child:IsA("Folder") then
			local nestedModels = findAllGlowModels(child)
			for _, model in ipairs(nestedModels) do
				table.insert(glowModels, model)
			end
		end
	end

	return glowModels
end

-- Create an outer glow effect (transparent part surrounding the cube)
local function createOuterGlow(part, color)
	local outerGlow = Instance.new("Part")
	outerGlow.Name = "OuterGlow"
	outerGlow.Parent = part.Parent
	outerGlow.Material = Enum.Material.Neon
	outerGlow.BrickColor = BrickColor.new(color)
	outerGlow.Color = color
	outerGlow.Anchored = true
	outerGlow.CanCollide = false
	outerGlow.Transparency = 0.7

	-- Handle different part types
	if part:IsA("Part") then
		outerGlow.Shape = part.Shape
	else
		-- For UnionOperations or other part types, default to Block
		outerGlow.Shape = Enum.PartType.Block
	end

	outerGlow.Size = part.Size * 1.1  -- Slightly larger
	outerGlow.CFrame = part.CFrame

	-- Keep it connected to the main part
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = part
	weld.Part1 = outerGlow
	weld.Parent = part

	return outerGlow
end

-- Enhanced glow function
local function makePartGlow(part, color)
	print(string.format("  Enhancing glow for %s (%s)", part.Name, part.ClassName))

	-- 1. Set main part properties based on part type
	if part:IsA("Part") then
		part.Material = Enum.Material.ForceField  -- More translucent than Neon
	elseif part:IsA("UnionOperation") then
		-- UnionOperations have limited material options
		part.Material = Enum.Material.Neon
	end

	part.Color = color
	part.Transparency = 0.2  -- Slightly transparent

	-- 2. Add/update PointLight
	local light = part:FindFirstChild("PointLight") or Instance.new("PointLight")
	light.Parent = part
	light.Color = color
	light.Brightness = 3  -- Brighter
	light.Range = 15      -- Larger range

	-- 3. Create outer glow effect
	local outerGlow = createOuterGlow(part, color)

	-- 4. Add pulsing animation
	local brightColor = color
	local darkColor = Color3.new(color.R * 0.4, color.G * 0.4, color.B * 0.4)

	-- Animate main part
	local partTween = TweenService:Create(part, GLOW_TWEEN_INFO, {
		Color = darkColor,
		Transparency = 0.5
	})

	-- Animate outer glow
	local glowTween = TweenService:Create(outerGlow, GLOW_TWEEN_INFO, {
		Color = darkColor,
		Transparency = 0.9
	})

	-- Animate light
	local lightTween = TweenService:Create(light, GLOW_TWEEN_INFO, {
		Brightness = 1,
		Range = 8
	})

	-- Store tweens for later cleanup
	table.insert(activeTweens, partTween)
	table.insert(activeTweens, glowTween)
	table.insert(activeTweens, lightTween)

	-- Start animations
	partTween:Play()
	glowTween:Play()
	lightTween:Play()

	print(string.format("  ✓ Enhanced glow applied to %s", part.Name))
end

-- Find all glow models in workspace
local allGlowModels = findAllGlowModels(workspace)
print(string.format("Found %d glow models", #allGlowModels))

-- Process each glow model
for _, model in ipairs(allGlowModels) do
	local colorName = model:GetAttribute("GlowColor")
	local color = GLOW_COLORS[colorName]

	if color then
		print(string.format("Processing: %s (Color: %s)", model.Name, colorName))

		-- Apply enhanced glow to all parts in the model
		for _, part in ipairs(model:GetChildren()) do
			if part:IsA("BasePart") then
				makePartGlow(part, color)
			end
		end
	else
		warn(string.format("Unknown color: %s for model: %s", colorName, model.Name))
	end
end

print("=== Enhanced Glow Manager Complete! ===")

-- Cleanup function
local function cleanup()
	for _, tween in ipairs(activeTweens) do
		tween:Cancel()
	end
	activeTweens = {}
end

-- Store for global access
_G.EnhancedGlowManager = {
	GLOW_COLORS = GLOW_COLORS,
	makePartGlow = makePartGlow,
	findAllGlowModels = findAllGlowModels,
	cleanup = cleanup
}</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterGui" referent="23">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="LocalScript" referent="24">
      <Properties>
        <string name="Name">StarterGui</string>
        <string name="Source"><![CDATA[--[[
    StarterGui Module - ForeverBuild2
    
    This is the main initialization script for the StarterGui.
    It handles loading and setting up all UI components.
]]

-- Add debug print to confirm script is running
print("StarterGui script starting...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Get shared module
local SharedModule = require(ReplicatedStorage.shared)

-- Local references to commonly used modules
local Constants = SharedModule.Constants
local GameManagerModule = SharedModule.GameManager
local CurrencyManagerModule = SharedModule.Economy.CurrencyManager

-- Create manager instances
local gameManager = GameManagerModule.new()
local currencyManager = CurrencyManagerModule.new()

-- Initialize managers
gameManager:Initialize()
currencyManager:Initialize()

local StarterGui = {}
StarterGui.__index = StarterGui

function StarterGui.new()
    local self = setmetatable({}, StarterGui)
    self.remoteEvents = ReplicatedStorage.Remotes
    self.gameManager = gameManager
    self.currencyManager = currencyManager
    self.player = Players.LocalPlayer
    return self
end

function StarterGui:Init()
    print("Initializing StarterGui...")
    
    -- Create main UI
    self:CreateMainUI()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Set up error handling
    self:SetupErrorHandling()
end

function StarterGui:SetupErrorHandling()
    -- Global error handler for client-side errors
    game:GetService("ScriptContext").Error:Connect(function(message, stackTrace, script)
        if self.ui and self.ui.Parent then
            self:ShowNotification("Error: " .. message)
            warn("UI Error: " .. message .. "\n" .. stackTrace)
        end
    end)
end

function StarterGui:CreateMainUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MainUI"
    screenGui.ResetOnSpawn = false -- Ensure UI persists across respawns
    screenGui.Parent = self.player:WaitForChild("PlayerGui")
    
    -- Create main frame
    local frame = Instance.new("Frame")
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = screenGui
    
    self.ui = screenGui
end

function StarterGui:SetupEventHandlers()
    -- Handle item description
    self.remoteEvents.ShowItemDescription.OnClientEvent:Connect(function(description)
        self:ShowItemDescription(description)
    end)
    
    -- Handle notifications
    self.remoteEvents.NotifyPlayer.OnClientEvent:Connect(function(message)
        self:ShowNotification(message)
    end)
end

function StarterGui:ShowItemDescription(description)
    -- Create description UI
    local descriptionUI = Instance.new("ScreenGui")
    descriptionUI.Name = "ItemDescription"
    descriptionUI.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "DescriptionFrame"
    frame.Size = UDim2.new(0, 300, 0, 200)
    frame.Position = UDim2.new(0.5, -150, 0.5, -100)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = descriptionUI
    
    local label = Instance.new("TextLabel")
    label.Name = "DescriptionLabel"
    label.Size = UDim2.new(1, -20, 1, -20)
    label.Position = UDim2.new(0, 10, 0, 10)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 16
    label.Font = Enum.Font.Gotham
    label.Text = description
    label.TextWrapped = true
    label.Parent = frame
    
    -- Add close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = frame
    
    closeButton.MouseButton1Click:Connect(function()
        descriptionUI:Destroy()
    end)
end

function StarterGui:ShowNotification(message)
    -- Create notification UI
    local notification = Instance.new("ScreenGui")
    notification.Name = "Notification"
    notification.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "NotificationFrame"
    frame.Size = UDim2.new(0, 300, 0, 50)
    frame.Position = UDim2.new(0.5, -150, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = notification
    
    local label = Instance.new("TextLabel")
    label.Name = "MessageLabel"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 18
    label.Font = Enum.Font.GothamBold
    label.Text = message
    label.Parent = frame
    
    -- Animate and destroy
    game:GetService("Debris"):AddItem(notification, 3)
end

-- Add this to self-initialize
StarterGui.new():Init()

return StarterGui
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="25">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="26">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="ModuleScript" referent="27">
        <Properties>
          <string name="Name">client</string>
          <string name="Source"><![CDATA[game.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false) ]]></string>
        </Properties>
        <Item class="Folder" referent="28">
          <Properties>
            <string name="Name">Currency</string>
          </Properties>
          <Item class="ModuleScript" referent="29">
            <Properties>
              <string name="Name">CurrencyUI</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(ReplicatedStorage.shared.core.Constants)

local CurrencyUI = {}
CurrencyUI.__index = CurrencyUI

-- Initialize a new CurrencyUI
function CurrencyUI.new()
    local self = setmetatable({}, CurrencyUI)
    self.player = Players.LocalPlayer
    self.ui = nil
    self:Initialize()
    return self
end

-- Initialize the CurrencyUI
function CurrencyUI:Initialize()
    -- Create UI
    self:CreateUI()
    
    -- Set up event handling
    self:SetupEventHandling()
    
    -- Initial balance update
    self:UpdateBalance(self.player:GetAttribute("Coins") or 0)
end

-- Create UI
function CurrencyUI:CreateUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CurrencyUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = self.player:WaitForChild("PlayerGui")
    
    -- Create main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 220, 0, 56)
    mainFrame.Position = UDim2.new(1, -240, 0, 24) -- Top right, 24px from top/right
    mainFrame.BackgroundTransparency = 0
    mainFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui

    -- Add rounded corners
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 14)
    corner.Parent = mainFrame

    -- Add outline
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(255, 223, 70)
    stroke.Parent = mainFrame

    -- Create coin icon
    local coinIcon = Instance.new("ImageLabel")
    coinIcon.Name = "CoinIcon"
    coinIcon.Size = UDim2.new(0, 40, 0, 40)
    coinIcon.Position = UDim2.new(0, 8, 0.5, -20)
    coinIcon.BackgroundTransparency = 1
    coinIcon.Image = "rbxassetid://101567167458494" -- TODO: Replace with actual coin icon
    coinIcon.Parent = mainFrame
    
    -- Create balance label
    local balanceLabel = Instance.new("TextLabel")
    balanceLabel.Name = "BalanceLabel"
    balanceLabel.Size = UDim2.new(0, 100, 1, 0)
    balanceLabel.Position = UDim2.new(0, 56, 0, 0)
    balanceLabel.BackgroundTransparency = 1
    balanceLabel.TextColor3 = Color3.fromRGB(255, 223, 70)
    balanceLabel.TextSize = 28
    balanceLabel.Font = Enum.Font.GothamBold
    balanceLabel.Text = "0"
    balanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    balanceLabel.Parent = mainFrame
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0, 40, 0, 40)
    purchaseButton.Position = UDim2.new(1, -48, 0.5, -20)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    purchaseButton.Text = "+"
    purchaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    purchaseButton.TextSize = 24
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Parent = mainFrame
    
    local purchaseCorner = Instance.new("UICorner")
    purchaseCorner.CornerRadius = UDim.new(0, 10)
    purchaseCorner.Parent = purchaseButton
    
    -- Store UI reference
    self.ui = screenGui
end

-- Set up event handling
function CurrencyUI:SetupEventHandling()
    -- Handle balance updates
    ReplicatedStorage.Remotes.UpdateBalance.OnClientEvent:Connect(function(balance)
        self:UpdateBalance(balance)
    end)
    
    -- Handle purchase button click
    self.ui.MainFrame.PurchaseButton.MouseButton1Click:Connect(function()
        self:ShowPurchaseMenu()
    end)
end

-- Update balance display
function CurrencyUI:UpdateBalance(balance)
    self.ui.MainFrame.BalanceLabel.Text = tostring(balance)
end

-- Show purchase menu
function CurrencyUI:ShowPurchaseMenu()
    -- Create purchase menu
    local purchaseMenu = Instance.new("Frame")
    purchaseMenu.Name = "PurchaseMenu"
    purchaseMenu.Size = UDim2.new(0, 300, 0, 400)
    purchaseMenu.Position = UDim2.new(0.5, -150, 0.5, -200)
    purchaseMenu.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    purchaseMenu.BorderSizePixel = 0
    purchaseMenu.Parent = self.ui
    
    -- Create title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 50)
    title.BackgroundTransparency = 1
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 24
    title.Font = Enum.Font.GothamBold
    title.Text = "Purchase Coins"
    title.Parent = purchaseMenu
    
    -- Create close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.Parent = purchaseMenu
    
    -- Create purchase options
    local yOffset = 60
    for _, product in ipairs(Constants.CURRENCY.PRODUCTS) do
        local option = self:CreatePurchaseOption(product, yOffset)
        option.Parent = purchaseMenu
        yOffset = yOffset + 80
    end
    
    -- Handle close button
    closeButton.MouseButton1Click:Connect(function()
        purchaseMenu:Destroy()
    end)
end

-- Create purchase option
function CurrencyUI:CreatePurchaseOption(product, yOffset)
    local option = Instance.new("Frame")
    option.Name = "Option_" .. product.id
    option.Size = UDim2.new(1, -40, 0, 70)
    option.Position = UDim2.new(0, 20, 0, yOffset)
    option.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    option.BorderSizePixel = 0
    
    -- Create coin amount
    local coinAmount = Instance.new("TextLabel")
    coinAmount.Name = "CoinAmount"
    coinAmount.Size = UDim2.new(0.6, 0, 1, 0)
    coinAmount.BackgroundTransparency = 1
    coinAmount.TextColor3 = Color3.fromRGB(255, 255, 255)
    coinAmount.TextSize = 20
    coinAmount.Font = Enum.Font.GothamBold
    coinAmount.Text = tostring(product.coins) .. " Coins"
    coinAmount.TextXAlignment = Enum.TextXAlignment.Left
    coinAmount.Parent = option
    
    -- Create price
    local price = Instance.new("TextLabel")
    price.Name = "Price"
    price.Size = UDim2.new(0.4, 0, 1, 0)
    price.Position = UDim2.new(0.6, 0, 0, 0)
    price.BackgroundTransparency = 1
    price.TextColor3 = Color3.fromRGB(255, 255, 255)
    price.TextSize = 20
    price.Font = Enum.Font.GothamBold
    price.Text = tostring(product.robux) .. " R$"
    price.TextXAlignment = Enum.TextXAlignment.Right
    price.Parent = option
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(1, 0, 0, 30)
    purchaseButton.Position = UDim2.new(0, 0, 1, 10)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    purchaseButton.BorderSizePixel = 0
    purchaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    purchaseButton.TextSize = 18
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Text = "Purchase"
    purchaseButton.Parent = option
    
    -- Handle purchase button
    purchaseButton.MouseButton1Click:Connect(function()
        self:PurchaseCoins(product.id)
    end)
    
    return option
end

-- Purchase coins
function CurrencyUI:PurchaseCoins(productId)
    MarketplaceService:PromptProductPurchase(self.player, productId)
end

return CurrencyUI ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="30">
          <Properties>
            <string name="Name">client</string>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Core modules
local SharedModule = require(ReplicatedStorage.shared)
local GameManagerModule = SharedModule.GameManager
local Constants = SharedModule.Constants

-- Initialize GameManager for client-side use
local GameManager = GameManagerModule.new()

-- UI Modules
local PurchaseDialogModule = SharedModule.UI.PurchaseDialog
local InventoryUIModule = SharedModule.UI.InventoryUI
local PlacedItemDialogModule = SharedModule.UI.PlacedItemDialog

-- Remote events/functions
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local BuyItemEvent = Remotes:WaitForChild("BuyItem")
local GetInventoryFunc = Remotes:WaitForChild("GetInventory")
local PlaceItemEvent = Remotes:WaitForChild("PlaceItem")
local InteractWithItemEvent = Remotes:WaitForChild("InteractWithItem")

-- State
local currentInventory = {}
local currentCurrency = 0
local isPlacingItem = false
local selectedItem = nil
local placementPreview = nil
local lastError = nil
local purchaseDialog = nil
local inventoryUI = nil
local placedItemDialog = nil

-- Helper to safely call RemoteFunctions
local function safeInvoke(remote, ...)
    local ok, result = pcall(function(...)
        return remote:InvokeServer(...)
    end, ...)
    if not ok then
        lastError = "A network error occurred. Please try again."
        warn("RemoteFunction error:", result)
        return { success = false, message = lastError }
    end
    if not result or not result.success then
        lastError = (result and result.message) or "Unknown error."
        return { success = false, message = lastError }
    end
    lastError = nil
    return result
end

-- Create inventory button
local function createInventoryButton(parent)
    local button = Instance.new("TextButton")
    button.Name = "InventoryButton"
    button.Size = UDim2.new(0, 120, 0, 40)
    button.Position = UDim2.new(1, -140, 0, 20)
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    button.Font = Enum.Font.GothamBold
    button.Text = "Inventory"
    button.TextSize = 18
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    -- Add hover effect
    button.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        }):Play()
    end)
    
    -- Set up click handler
    button.MouseButton1Click:Connect(function()
        if lastError then
            warn("Error showing inventory:", lastError)
            return
        end
        local result = safeInvoke(GetInventoryFunc)
        if result.success then
            currentInventory = result.inventory
            currentCurrency = result.currency
            if inventoryUI then
                inventoryUI:UpdateInventory(currentInventory, currentCurrency)
                inventoryUI:Show()
            else
                warn("InventoryUI not initialized")
            end
        else
            warn("Failed to get inventory:", result.message)
        end
    end)
    
    return button
end

-- Initialize UI
local function initializeUI()
    -- Create main UI container
    local uiContainer = Instance.new("ScreenGui")
    uiContainer.Name = "ItemSystemUI"
    uiContainer.ResetOnSpawn = false
    uiContainer.Parent = player.PlayerGui
    
    -- Create inventory button
    createInventoryButton(uiContainer)
    
    -- Initialize UI modules
    purchaseDialog = PurchaseDialogModule.new()
    purchaseDialog:Initialize(uiContainer)

    inventoryUI = InventoryUIModule.new()
    inventoryUI:Initialize(uiContainer)

    placedItemDialog = PlacedItemDialogModule.new()
    placedItemDialog:Initialize(uiContainer)
    
    -- Set up item selection
    inventoryUI.OnItemSelected = function(itemName)
        if lastError then
            warn("Error selecting item:", lastError)
            return
        end
        if not currentInventory[itemName] or currentInventory[itemName] &lt;= 0 then
            warn("You do not own this item.")
            return
        end
        -- Start placement mode
        isPlacingItem = true
        selectedItem = itemName
        inventoryUI:Hide()
        -- Create placement preview
        if placementPreview then
            placementPreview:Destroy()
        end
        -- Simple preview model
        placementPreview = Instance.new("Part")
        placementPreview.Name = "PlacementPreview"
        placementPreview.Anchored = true
        placementPreview.CanCollide = false
        placementPreview.Transparency = 0.5
        placementPreview.Size = Vector3.new(4, 4, 4)
        placementPreview.BrickColor = BrickColor.new("Bright blue")
        placementPreview.Parent = workspace
    end
    
    -- Set up placed item interaction
    placedItemDialog.OnActionSelected = function(itemId, action)
        InteractWithItemEvent:FireServer(itemId, action)
    end
end

-- Handle proximity prompts
local function setupProximityPrompts()
    -- Find all items with proximity prompts
    local function onItemFound(item)
        if item:GetAttribute("item") then
            local prompt = item:FindFirstChild("ProximityPrompt")
            if not prompt then
                prompt = Instance.new("ProximityPrompt")
                prompt.Name = "ItemPrompt"
                prompt.ActionText = "Purchase"
                prompt.ObjectText = item:GetAttribute("item")
                prompt.HoldDuration = 0
                prompt.MaxActivationDistance = 10
                prompt.Parent = item
            end
            
            prompt.Triggered:Connect(function()
                if lastError then
                    warn("Error purchasing item:", lastError)
                    return
                end
                local itemName = item:GetAttribute("item")
                if itemName and purchaseDialog then
                    purchaseDialog:Show(itemName, function(quantity)
                        BuyItemEvent:FireServer(itemName, quantity)
                    end)
                end
            end)
        end
    end
    
    -- Set up existing items
    for _, item in ipairs(workspace:GetDescendants()) do
        onItemFound(item)
    end
    
    -- Watch for new items
    workspace.DescendantAdded:Connect(onItemFound)
end

-- Handle item placement
local function setupPlacement()
    local mouse = player:GetMouse()
    
    -- Handle mouse movement
    RunService.RenderStepped:Connect(function()
        if not isPlacingItem or not selectedItem or not placementPreview then return end
        
        -- Update preview position
        local hit, position, normal = workspace:FindPartOnRay(
            Ray.new(mouse.UnitRay.Origin, mouse.UnitRay.Direction * 100),
            placementPreview
        )
        
        if hit then
            placementPreview.CFrame = CFrame.new(position) * CFrame.new(0, placementPreview.Size.Y/2, 0)
        end
    end)
    
    -- Handle mouse clicks
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if isPlacingItem and selectedItem and placementPreview then
                -- Place item
                local position = placementPreview.Position
                local rotation = placementPreview.Orientation
                PlaceItemEvent:FireServer(selectedItem, position, rotation)
                
                -- Reset placement mode
                isPlacingItem = false
                selectedItem = nil
                placementPreview:Destroy()
                placementPreview = nil
            end
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            if isPlacingItem then
                -- Cancel placement
                isPlacingItem = false
                selectedItem = nil
                if placementPreview then
                    placementPreview:Destroy()
                    placementPreview = nil
                end
            end
        end
    end)
end

-- Initialize
print("Client script starting...")
initializeUI()
setupProximityPrompts()
setupPlacement()

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    -- Reset placement mode if active
    if isPlacingItem and placementPreview then
        isPlacingItem = false
        selectedItem = nil
        placementPreview:Destroy()
        placementPreview = nil
    end
end)

-- Initial inventory load
if GetInventoryFunc then
    local result = safeInvoke(GetInventoryFunc)
    if result and result.success then
        currentInventory = result.inventory or {}
        currentCurrency = result.currency or 0
        if inventoryUI then
            inventoryUI:UpdateInventory(currentInventory, currentCurrency)
        end
    else
        warn("Failed to load initial inventory")
    end
else
    warn("GetInventory RemoteFunction not found")
end</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="31">
          <Properties>
            <string name="Name">interaction</string>
          </Properties>
          <Item class="ModuleScript" referent="32">
            <Properties>
              <string name="Name">InteractionSystem</string>
              <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

-- Add debug print to confirm module is loading
print("InteractionSystem module loading...")

local Constants = require(ReplicatedStorage.shared.core.Constants)

-- BREAKING THE CIRCULAR DEPENDENCY: Use lazy loading instead of direct requires
-- We'll load these modules when they're needed, not at the top level
local PurchaseDialog, InventoryUI, PlacedItemDialog

-- Helper to safely require a module
local function safeRequire(path)
    local success, result = pcall(function()
        return require(path)
    end)
    
    if success then
        return result
    else
        warn("Failed to require module at path: ", path)
        warn("Error: ", result)
        return {}
    end
end

-- Lazy-loading function for UI modules
local function getUIModules()
    if not PurchaseDialog then
        PurchaseDialog = safeRequire(ReplicatedStorage.shared.core.ui.PurchaseDialog)
    end
    
    if not InventoryUI then
        InventoryUI = safeRequire(ReplicatedStorage.shared.core.ui.InventoryUI)
    end
    
    if not PlacedItemDialog then
        PlacedItemDialog = safeRequire(ReplicatedStorage.shared.core.ui.PlacedItemDialog)
    end
    
    return {
        PurchaseDialog = PurchaseDialog,
        InventoryUI = InventoryUI,
        PlacedItemDialog = PlacedItemDialog
    }
end

local InteractionSystem = {}
InteractionSystem.__index = InteractionSystem

function InteractionSystem.new()
    local self = setmetatable({}, InteractionSystem)
    self.player = Players.LocalPlayer
    self.mouse = self.player:GetMouse()
    self.currentTarget = nil
    self.interactionDistance = 10 -- Maximum distance for interaction
    self.ui = nil
    self.remoteEvents = ReplicatedStorage.Remotes
    return self
end

function InteractionSystem:Initialize()
    print("InteractionSystem initialized")
    
    -- Create UI
    self:CreateUI()
    
    -- Set up input handling
    self:SetupInputHandling()
    
    -- Set up mouse movement
    self:SetupMouseHandling()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Set up inventory key
    self:SetupInventoryKey()
end

function InteractionSystem:CreateUI()
    -- Remove old tooltip UI creation
    -- Instead, prepare BillboardGui template for proximity popup
    self.billboardTemplate = Instance.new("BillboardGui")
    self.billboardTemplate.Name = "ProximityInteractUI"
    self.billboardTemplate.Size = UDim2.new(0, 200, 0, 50)
    self.billboardTemplate.StudsOffset = Vector3.new(0, 3, 0)
    self.billboardTemplate.AlwaysOnTop = true
    self.billboardTemplate.Enabled = false

    local bg = Instance.new("Frame")
    bg.Size = UDim2.new(1, 0, 1, 0)
    bg.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    bg.BackgroundTransparency = 0.2
    bg.BorderSizePixel = 0
    bg.Parent = self.billboardTemplate

    local label = Instance.new("TextLabel")
    label.Name = "Title"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Constants.UI_COLORS.TEXT
    label.TextSize = 20
    label.Font = Enum.Font.GothamBold
    label.Text = "[E] Interact"
    label.Parent = bg
end

function InteractionSystem:SetupInputHandling()
    -- Handle interaction input (E key)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.E then
            self:AttemptInteraction()
        end
    end)
end

function InteractionSystem:SetupMouseHandling()
    -- Update current target on mouse movement
    game:GetService("RunService").RenderStepped:Connect(function()
        self:UpdateCurrentTarget()
    end)
end

function InteractionSystem:UpdateCurrentTarget()
    local target = self.mouse.Target
    if not target then
        self:ClearCurrentTarget()
        return
    end
    
    -- Check if target is a placed item
    local placedItem = self:GetPlacedItemFromPart(target)
    if not placedItem then
        self:ClearCurrentTarget()
        return
    end
    
    -- Check distance
    local distance = (target.Position - self.player.Character.HumanoidRootPart.Position).Magnitude
    if distance > self.interactionDistance then
        self:ClearCurrentTarget()
        return
    end
    
    -- Update current target
    self.currentTarget = placedItem
    
    -- Show interaction UI
    self:ShowInteractionUI(placedItem)
end

function InteractionSystem:ClearCurrentTarget()
    if self.currentTarget then
        self:HideInteractionUI()
        self.currentTarget = nil
    end
end

function InteractionSystem:GetPlacedItemFromPart(part)
    local current = part
    while current and current ~= workspace do
        if current:IsA("Model") and current:GetAttribute("item") then
            return {
                id = current.Name,
                model = current
            }
        end
        current = current.Parent
    end
    return nil
end

function InteractionSystem:ShowInteractionUI(placedItem)
    -- Remove old tooltip logic
    -- Attach BillboardGui to the item model's PrimaryPart
    if not placedItem.model.PrimaryPart then
        placedItem.model.PrimaryPart = placedItem.model:FindFirstChildWhichIsA("BasePart")
    end
    if not placedItem.model.PrimaryPart then return end

    -- Remove any existing BillboardGui
    local existing = placedItem.model.PrimaryPart:FindFirstChild("ProximityInteractUI")
    if existing then existing:Destroy() end

    local bb = self.billboardTemplate:Clone()
    bb.Enabled = true
    bb.Parent = placedItem.model.PrimaryPart
end

function InteractionSystem:HideInteractionUI()
    -- Remove BillboardGui from all items in workspace
    for _, model in ipairs(workspace:GetDescendants()) do
        if model:IsA("Model") and model.PrimaryPart then
            local bb = model.PrimaryPart:FindFirstChild("ProximityInteractUI")
            if bb then bb:Destroy() end
        end
    end
end

function InteractionSystem:AttemptInteraction()
    if not self.currentTarget then return end
    
    -- Get available interactions
    local interactions = self:GetAvailableInteractions(self.currentTarget)
    if not interactions or #interactions == 0 then return end
    
    -- If only one interaction is available, use it
    if #interactions == 1 then
        self:PerformInteraction(self.currentTarget, interactions[1])
        return
    end
    
    -- Show interaction menu
    self:ShowInteractionMenu(interactions)
end

function InteractionSystem:GetAvailableInteractions(placedItem)
    -- Request available interactions from server
    return ReplicatedStorage.Remotes.GetAvailableInteractions:InvokeServer(placedItem)
end

function InteractionSystem:PerformInteraction(placedItem, interactionType)
    -- Send interaction request to server
    ReplicatedStorage.Remotes.InteractWithItem:FireServer(placedItem, interactionType)
end

function InteractionSystem:ShowInteractionMenu(interactions)
    -- Use the same UI as ShowInteractionUI
    self:ShowInteractionUI(self.currentTarget)
end

function InteractionSystem:SetupEventHandlers()
    -- Handle interaction responses
    self.remoteEvents.NotifyPlayer.OnClientEvent:Connect(function(message)
        self:ShowNotification(message)
    end)
end

function InteractionSystem:ShowNotification(message)
    -- Create notification UI
    local notification = Instance.new("ScreenGui")
    notification.Name = "Notification"
    notification.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "NotificationFrame"
    frame.Size = UDim2.new(0, 300, 0, 50)
    frame.Position = UDim2.new(0.5, -150, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = notification
    
    local label = Instance.new("TextLabel")
    label.Name = "MessageLabel"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 18
    label.Font = Enum.Font.GothamBold
    label.Text = message
    label.Parent = frame
    
    -- Animate and destroy
    game:GetService("Debris"):AddItem(notification, 3)
end

function InteractionSystem:SetupInventoryKey()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.I then
            self:OpenInventory()
        end
    end)
end

function InteractionSystem:OpenInventory()
    -- Fetch inventory from server
    local inventory = ReplicatedStorage.Remotes.GetInventory:InvokeServer()
    if not inventory or not inventory.success or not inventory.inventory or next(inventory.inventory) == nil then
        InventoryUI.ShowError("Your inventory is empty.")
        return
    end
    InventoryUI.Show()
    -- Add logic to update inventory display if needed
end

return InteractionSystem</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>