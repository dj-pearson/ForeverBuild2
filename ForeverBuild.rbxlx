<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">GameData</string>
      </Properties>
      <Item class="StringValue" referent="2">
        <Properties>
          <string name="Name">Structure</string>
          <string name="Value"><![CDATA[  # ForeverBuild2 Structure File
# This file defines all items, their properties, and organization
# Format: [Category] followed by item entries

[Items]
# Basic items
brick_cube=Brick Cube,100
wood_cube=Wood Cube,150
stone_cube=Stone Cube,175
grass_cube=Grass Cube,150
fabric_cube=Fabric Cube,125
glass_cube=Glass Cube,200
water_cube=Water Cube,225
fire_cube=Fire Cube,250

# Glowing items
glow_red_cube=Red Glowing Cube,300
glow_blue_cube=Blue Glowing Cube,300
glow_green_cube=Green Glowing Cube,300
glow_purple_cube=Purple Glowing Cube,350
glow_yellow_cube=Yellow Glowing Cube,325
glow_white_cube=White Glowing Cube,400
# Interactive items
gear=Spinning Gear,500
trampoline=Trampoline,750

# Teleportation items
portal_blue=Blue Portal,1000
portal_red=Red Portal,1000

[Categories]
# Category definitions
basic=brick_cube,wood_cube,stone_cube,grass_cube,fabric_cube,glass_cube,water_cube,fire_cube
glow=glow_red_cube,glow_blue_cube,glow_green_cube,glow_purple_cube,glow_yellow_cube,glow_white_cube
interactive=gear,trampoline
teleport=portal_blue,portal_red

[Properties]
# Properties for specific items
trampoline=bounceHeight:20,bounceCooldown:1.5
gear=rotationSpeed:2
portal_blue=linkedPortal:portal_red,cooldown:5
portal_red=linkedPortal:portal_blue,cooldown:5
glow_red_cube=glowIntensity:1.5,glowColor:255,0,0
glow_blue_cube=glowIntensity:1.5,glowColor:0,0,255
glow_green_cube=glowIntensity:1.5,glowColor:0,255,0
    end
    
    if attrCount > 0 then
        attrStr = attrStr .. "]"
        info = info .. attrStr
    end
    
    -- Print the current object
    print(prefix .. connector .. icon .. " " .. info)
    
    -- Get children and sort them (Folders first, then alphabetically)
    local children = object:GetChildren()
    table.sort(children, function(a, b)
        if a:IsA("Folder") and not b:IsA("Folder") then
            return true
        elseif not a:IsA("Folder") and b:IsA("Folder") then
            return false
        else
            return a.Name < b.Name
        end
    end)
    
    -- Print children
    for i, child in ipairs(children) do
        local isLastChild = (i == #children)
        printTree(child, depth + 1, isLastChild, nextPrefix)
    end
end

-- Add a collapsible version for large structures
local function printTreeCollapsible(object, depth, isLast, prefix, maxDepth)
    depth = depth or 0
    maxDepth = maxDepth or 3  -- Default max depth
    prefix = prefix or ""
    
    if depth > maxDepth then
        return
    end
    
    -- Same tree printing logic as above
    local connector = isLast and "â””â”€ " or "â”œâ”€ "
    local nextPrefix = prefix .. (isLast and "   " or "â”‚  ")
    
    local icon = getObjectIcon(object)
    local info = string.format("%s (%s)", object.Name, object.ClassName)
    
    local attributes = object:GetAttributes()
    local attrCount = 0
    local attrStr = ""
    
    for key, value in pairs(attributes) do
        attrCount = attrCount + 1
        if attrCount == 1 then
            attrStr = string.format(" [%s=%s", key, tostring(value))
        else
            attrStr = attrStr .. string.format(", %s=%s", key, tostring(value))
        endglow_purple_cube=glowIntensity:1.5,glowColor:125,0,255
glow_yellow_cube=glowIntensity:1.5,glowColor:255,255,0
glow_white_cube=glowIntensity:2.0,glowColor:255,255,255

[Tiers]
# Pricing tiers for items
tier1=100
tier2=200
tier3=300
tier4=500
tier5=750
tier6=1000

[TierAssignments]
# Assign items to tiers
tier1=brick_cube,wood_cube,grass_cube,fabric_cube
tier2=stone_cube,glass_cube,water_cube
tier3=fire_cube,glow_red_cube,glow_blue_cube,glow_green_cube,glow_yellow_cube
tier4=glow_purple_cube,glow_white_cube,gear
tier5=trampoline
tier6=portal_blue,portal_red

[Interactions]
# Define possible interactions for items
trampoline=jump,examine,customize
gear=spin,examine,pickup
portal_blue=teleport,examine,configure
portal_red=teleport,examine,configure
    
    for i, child in ipairs(children) do
        local isLastChild = (i == #children)
        printTreeCollapsible(child, depth + 1, isLastChild, nextPrefix, maxDepth)
    end
end

-- Statistics function
local function getWorkspaceStats()
    local stats = {
        totalModels = 0,
        totalParts = 0,
        totalFolders = 0,
        totalScripts = 0,
        totalOthers = 0
    }
    
    local function countObjects(parent)
        for _, child in ipairs(parent:GetChildren()) do
            if child:IsA("Model") then
                stats.totalModels = stats.totalModels + 1
            elseif child:IsA("BasePart") then
                stats.totalParts = stats.totalParts + 1
            elseif child:IsA("Folder") then
                stats.totalFolders = stats.totalFolders + 1
            elseif child:IsA("BaseScript") then
                stats.totalScripts = stats.totalScripts + 1
            else
                stats.totalOthers = stats.totalOthers + 1
            end
            countObjects(child)
        end
    end
    
    countObjects(workspace)
    return stats
end

-- Main execution
print("=== WORKSPACE STRUCTURE ===")
print("ðŸŒŽ " .. workspace.Name .. " (Workspace)")
print("â”‚")

local children = workspace:GetChildren()
for i, child in ipairs(children) do
    local isLast = (i == #children)
    printTree(child, 1, isLast, "")
end

print("\n=== WORKSPACE STATISTICS ===")
local stats = getWorkspaceStats()
print("ðŸ“ Folders: " .. stats.totalFolders)
print("ðŸ“‹ Models: " .. stats.totalModels)
print("ðŸ§Š Parts: " .. stats.totalParts)
print("ðŸ“ Scripts: " .. stats.totalScripts)
print("â“ Others: " .. stats.totalOthers)
print("ðŸ“Š Total Objects: " .. (stats.totalFolders + stats.totalModels + stats.totalParts + stats.totalScripts + stats.totalOthers))

-- Alternative collapsible view for large workspaces
print("\n=== COLLAPSED VIEW (Max Depth: 3) ===")
print("ðŸŒŽ " .. workspace.Name .. " (Workspace)")
print("â”‚")

for i, child in ipairs(children) do
    local isLast = (i == #children)
    printTreeCollapsible(child, 1, isLast, "", 3)
end  -  Studio
  15:02:32.629  === WORKSPACE STRUCTURE ===  -  Edit
  15:02:32.629  ðŸŒŽ Workspace (Workspace)  -  Edit
  15:02:32.629  â”‚  -  Edit
  15:02:32.629  â”œâ”€ â“ Terrain (Terrain)  -  Edit
  15:02:32.629  â”œâ”€ ðŸ“· Camera (Camera)  -  Edit
  15:02:32.629  â”œâ”€ ðŸ“ Items (Folder)  -  Edit
  15:02:32.630  â”‚  â”œâ”€ ðŸ“ Basic (Folder)  -  Edit
  15:02:32.630  â”‚  â”‚  â”œâ”€ ðŸ“ Glow (Folder)  -  Edit
  15:02:32.630  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glow_Blue_Cube (Model) [GlowColor=Blue]  -  Edit
  15:02:32.630  â”‚  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.630  â”‚  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.630  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glow_Green_Cube (Model) [GlowColor=Green]  -  Edit
  15:02:32.630  â”‚  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.631  â”‚  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.631  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glow_Purple_Cube (Model) [GlowColor=Purple]  -  Edit
  15:02:32.631  â”‚  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.631  â”‚  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.631  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glow_Red_Cube (Model) [GlowColor=Red]  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glow_White_Cube (Model) [GlowColor=White]  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.632  â”‚  â”‚  â”‚  â””â”€ ðŸ“‹ Glow_Yellow_Cube (Model) [GlowColor=Yellow]  -  Edit
  15:02:32.633  â”‚  â”‚  â”‚     â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.633  â”‚  â”‚  â”‚        â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.633  â”‚  â”‚  â”œâ”€ ðŸ“‹ Brick_Cube (Model)  -  Edit
  15:02:32.633  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.633  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.633  â”‚  â”‚  â”œâ”€ ðŸ“‹ Fabric_Cube (Model)  -  Edit
  15:02:32.634  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.634  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.634  â”‚  â”‚  â”œâ”€ ðŸ“‹ Fire_Cube (Model)  -  Edit
  15:02:32.634  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.635  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.635  â”‚  â”‚  â”œâ”€ ðŸ“‹ Gear (Model)  -  Edit
  15:02:32.635  â”‚  â”‚  â”‚  â””â”€ ðŸ”— Gear (UnionOperation)  -  Edit
  15:02:32.635  â”‚  â”‚  â”‚     â””â”€ ðŸ“ Spinning Script (Script)  -  Edit
  15:02:32.635  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glass_Cube (Model)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.636  â”‚  â”‚  â”œâ”€ ðŸ“‹ Grass_Cube (Model)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.636  â”‚  â”‚  â”œâ”€ ðŸ“‹ Stone_Cube (Model)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.636  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.636  â”‚  â”‚  â”œâ”€ ðŸ“‹ Water_Cube (Model)  -  Edit
  15:02:32.637  â”‚  â”‚  â”‚  â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.637  â”‚  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.637  â”‚  â”‚  â””â”€ ðŸ“‹ Wood_Cube (Model)  -  Edit
  15:02:32.637  â”‚  â”‚     â””â”€ ðŸ”— SmoothCube (UnionOperation)  -  Edit
  15:02:32.637  â”‚  â”‚        â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.637  â”‚  â”œâ”€ ðŸ“ Exclusive (Folder)  -  Edit
  15:02:32.637  â”‚  â”œâ”€ ðŸ“ Free_items (Folder)  -  Edit
  15:02:32.637  â”‚  â”œâ”€ ðŸ“ Random_Drop (Folder)  -  Edit
  15:02:32.637  â”‚  â”œâ”€ ðŸ“ Rare (Folder)  -  Edit
  15:02:32.637  â”‚  â”œâ”€ ðŸ“ Secondary (Folder)  -  Edit
  15:02:32.638  â”‚  â”‚  â””â”€ ðŸ“ Teleport Portals (Folder)  -  Edit
  15:02:32.638  â”‚  â”‚     â”œâ”€ ðŸ“‹ PortalBlue (Model)  -  Edit
  15:02:32.638  â”‚  â”‚     â”‚  â”œâ”€ ðŸ§Š BlueArrive (Part)  -  Edit
  15:02:32.638  â”‚  â”‚     â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.638  â”‚  â”‚     â”‚  â”œâ”€ ðŸ§Š BlueTeleport (Part)  -  Edit
  15:02:32.639  â”‚  â”‚     â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.639  â”‚  â”‚     â”‚  â”œâ”€ ðŸ“‹ Model (Model)  -  Edit
  15:02:32.639  â”‚  â”‚     â”‚  â”‚  â”œâ”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚  â”œâ”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚  â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚  â””â”€ ðŸ”— Union (UnionOperation)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”‚     â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â””â”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.640  â”‚  â”‚     â”œâ”€ ðŸ“‹ PortalRed (Model)  -  Edit
  15:02:32.640  â”‚  â”‚     â”‚  â”œâ”€ ðŸ“‹ Model (Model)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â”œâ”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â”œâ”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚  â””â”€ ðŸ”— Union (UnionOperation)  -  Edit
  15:02:32.641  â”‚  â”‚     â”‚  â”‚     â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.642  â”‚  â”‚     â”‚  â”œâ”€ ðŸ§Š Part (Part)  -  Edit
  15:02:32.642  â”‚  â”‚     â”‚  â”œâ”€ ðŸ§Š RedArrive (Part)  -  Edit
  15:02:32.642  â”‚  â”‚     â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.642  â”‚  â”‚     â”‚  â””â”€ ðŸ§Š RedTeleport (Part)  -  Edit
  15:02:32.643  â”‚  â”‚     â”‚     â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.643  â”‚  â”‚     â”œâ”€ ðŸ“ Script (Script)  -  Edit
  15:02:32.643  â”‚  â”‚     â””â”€ ðŸ“· ThumbnailCamera (Camera)  -  Edit
  15:02:32.643  â”‚  â””â”€ ðŸ“ Weapons (Folder)  -  Edit
  15:02:32.643  â”œâ”€ ðŸ“ World_Items (Folder)  -  Edit
  15:02:32.643  â”‚  â”œâ”€ ðŸ“‹ Trampoline (Model)  -  Edit
  15:02:32.643  â”‚  â”‚  â”œâ”€ ðŸ”— Trampoline (UnionOperation)  -  Edit
  15:02:32.644  â”‚  â”‚  â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.644  â”‚  â”‚  â”œâ”€ ðŸ§Š TrampolineBouncyThing (Part)  -  Edit
  15:02:32.644  â”‚  â”‚  â”‚  â”œâ”€ ðŸ“ BouncePad (Script)  -  Edit
  15:02:32.645  â”‚  â”‚  â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.645  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.645  â”‚  â”‚  â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.645  â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.645  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.645  â”‚  â”‚  â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.646  â”‚  â”‚  â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â”‚  â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â”‚  â””â”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.646  â”‚  â”‚     â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â”‚     â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.646  â”‚  â””â”€ ðŸ“‹ Trampoline (Model)  -  Edit
  15:02:32.647  â”‚     â”œâ”€ ðŸ”— Trampoline (UnionOperation)  -  Edit
  15:02:32.649  â”‚     â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.649  â”‚     â”œâ”€ ðŸ§Š TrampolineBouncyThing (Part)  -  Edit
  15:02:32.650  â”‚     â”‚  â”œâ”€ ðŸ“ BouncePad (Script)  -  Edit
  15:02:32.652  â”‚     â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.653  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.653  â”‚     â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.653  â”‚     â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.653  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.654  â”‚     â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.654  â”‚     â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.654  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.655  â”‚     â”‚  â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.655  â”‚     â”‚  â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.656  â”‚     â””â”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.656  â”‚        â”œâ”€ â“ Weld (Weld)  -  Edit
  15:02:32.657  â”‚        â””â”€ â“ Weld (Weld)  -  Edit
  15:02:32.657  â””â”€ ðŸ“ Main (Folder)  -  Edit
  15:02:32.657     â”œâ”€ ðŸ§Š Baseplate (Part)  -  Edit
  15:02:32.658     â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.658     â””â”€ ðŸ“‹ Board (Model)  -  Edit
  15:02:32.658        â”œâ”€ ðŸ§Š Board (Part)  -  Edit
  15:02:32.658        â””â”€ ðŸ§Š SpawnLocation (SpawnLocation)  -  Edit
  15:02:32.659           â””â”€ â“ Decal (Decal)  -  Edit
  15:02:32.659  
=== WORKSPACE STATISTICS ===  -  Edit
  15:02:32.659  ðŸ“ Folders: 12  -  Edit
  15:02:32.659  ðŸ“‹ Models: 22  -  Edit
  15:02:32.660  ðŸ§Š Parts: 43  -  Edit
  15:02:32.660  ðŸ“ Scripts: 4  -  Edit
  15:02:32.660  â“ Others: 84  -  Edit
  15:02:32.660  ðŸ“Š Total Objects: 165  -  Edit
  15:02:32.660  
=== COLLAPSED VIEW (Max Depth: 3) ===  -  Edit
  15:02:32.661  ðŸŒŽ Workspace (Workspace)  -  Edit
  15:02:32.661  â”‚  -  Edit
  15:02:32.661  â”œâ”€ â“ Terrain (Terrain)  -  Edit
  15:02:32.661  â”œâ”€ ðŸ“· Camera (Camera)  -  Edit
  15:02:32.662  â”œâ”€ ðŸ“ Items (Folder)  -  Edit
  15:02:32.662  â”‚  â”œâ”€ ðŸ“ Basic (Folder)  -  Edit
  15:02:32.662  â”‚  â”‚  â”œâ”€ ðŸ“ Glow (Folder)  -  Edit
  15:02:32.662  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (6 more items)  -  Edit
  15:02:32.663  â”‚  â”‚  â”œâ”€ ðŸ“‹ Brick_Cube (Model)  -  Edit
  15:02:32.663  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.663  â”‚  â”‚  â”œâ”€ ðŸ“‹ Fabric_Cube (Model)  -  Edit
  15:02:32.663  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.663  â”‚  â”‚  â”œâ”€ ðŸ“‹ Fire_Cube (Model)  -  Edit
  15:02:32.663  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.663  â”‚  â”‚  â”œâ”€ ðŸ“‹ Gear (Model)  -  Edit
  15:02:32.664  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.664  â”‚  â”‚  â”œâ”€ ðŸ“‹ Glass_Cube (Model)  -  Edit
  15:02:32.664  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.664  â”‚  â”‚  â”œâ”€ ðŸ“‹ Grass_Cube (Model)  -  Edit
  15:02:32.664  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.665  â”‚  â”‚  â”œâ”€ ðŸ“‹ Stone_Cube (Model)  -  Edit
  15:02:32.665  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.665  â”‚  â”‚  â”œâ”€ ðŸ“‹ Water_Cube (Model)  -  Edit
  15:02:32.665  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.666  â”‚  â”‚  â””â”€ ðŸ“‹ Wood_Cube (Model)  -  Edit
  15:02:32.666  â”‚  â”‚     â””â”€ ðŸ“‚ ... (1 more items)  -  Edit
  15:02:32.666  â”‚  â”œâ”€ ðŸ“ Exclusive (Folder)  -  Edit
  15:02:32.667  â”‚  â”œâ”€ ðŸ“ Free_items (Folder)  -  Edit
  15:02:32.667  â”‚  â”œâ”€ ðŸ“ Random_Drop (Folder)  -  Edit
  15:02:32.667  â”‚  â”œâ”€ ðŸ“ Rare (Folder)  -  Edit
  15:02:32.668  â”‚  â”œâ”€ ðŸ“ Secondary (Folder)  -  Edit
  15:02:32.668  â”‚  â”‚  â””â”€ ðŸ“ Teleport Portals (Folder)  -  Edit
  15:02:32.668  â”‚  â”‚     â””â”€ ðŸ“‚ ... (4 more items)  -  Edit
  15:02:32.668  â”‚  â””â”€ ðŸ“ Weapons (Folder)  -  Edit
  15:02:32.668  â”œâ”€ ðŸ“ World_Items (Folder)  -  Edit
  15:02:32.668  â”‚  â”œâ”€ ðŸ“‹ Trampoline (Model)  -  Edit
  15:02:32.669  â”‚  â”‚  â”œâ”€ ðŸ”— Trampoline (UnionOperation)  -  Edit
  15:02:32.669  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (6 more items)  -  Edit
  15:02:32.669  â”‚  â”‚  â”œâ”€ ðŸ§Š TrampolineBouncyThing (Part)  -  Edit
  15:02:32.670  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (7 more items)  -  Edit
  15:02:32.670  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.670  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.670  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.670  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.670  â”‚  â”‚  â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.670  â”‚  â”‚  â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.671  â”‚  â”‚  â””â”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.671  â”‚  â”‚     â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.671  â”‚  â””â”€ ðŸ“‹ Trampoline (Model)  -  Edit
  15:02:32.671  â”‚     â”œâ”€ ðŸ”— Trampoline (UnionOperation)  -  Edit
  15:02:32.672  â”‚     â”‚  â””â”€ ðŸ“‚ ... (6 more items)  -  Edit
  15:02:32.672  â”‚     â”œâ”€ ðŸ§Š TrampolineBouncyThing (Part)  -  Edit
  15:02:32.672  â”‚     â”‚  â””â”€ ðŸ“‚ ... (7 more items)  -  Edit
  15:02:32.672  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.672  â”‚     â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.673  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.673  â”‚     â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.673  â”‚     â”œâ”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.673  â”‚     â”‚  â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.673  â”‚     â””â”€ ðŸ”— TrampolineLeg (UnionOperation)  -  Edit
  15:02:32.673  â”‚        â””â”€ ðŸ“‚ ... (2 more items)  -  Edit
  15:02:32.674  â””â”€ ðŸ“ Main (Folder)  -  Edit
  15:02:32.674     â”œâ”€ ðŸ§Š Baseplate (Part)  -  Edit
  15:02:32.674     â”‚  â””â”€ â“ Texture (Texture)  -  Edit
  15:02:32.674     â””â”€ ðŸ“‹ Board (Model)  -  Edit
  15:02:32.674        â”œâ”€ ðŸ§Š Board (Part)  -  Edit
  15:02:32.675        â””â”€ ðŸ§Š SpawnLocation (SpawnLocation)  -  Edit
  15:02:32.675           â””â”€ ðŸ“‚ ... (1 more items)  -  Edit]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="3">
      <Properties>
        <string name="Name">shared</string>
        <string name="Source"><![CDATA[--[[
    Shared Module - ForeverBuild2
    
    This is the main entry point for all shared modules.
    When requiring this module, you'll get access to all sub-modules.
]]

local SharedModule = {}

SharedModule.Constants = require(script.core.Constants)
SharedModule.GameManager = require(script.core.GameManager)
SharedModule.UI = require(script.core.ui)
SharedModule.Interaction = require(script.core.interaction)
SharedModule.Placement = require(script.core.placement)
SharedModule.Inventory = require(script.core.inventory)
SharedModule.Economy = require(script.core.economy)

function SharedModule.Init()
    print("Initializing SharedModule...")

    -- Initialize submodules if they have Init/Initialize
    for _, sub in pairs({
        SharedModule.GameManager,
        SharedModule.UI,
        SharedModule.Interaction,
        SharedModule.Placement,
        SharedModule.Inventory,
        SharedModule.Economy
    }) do
        if sub.Init then sub.Init() end
        if sub.Initialize then sub.Initialize() end
    end

    return true
end

return SharedModule
]]></string>
      </Properties>
      <Item class="Folder" referent="4">
        <Properties>
          <string name="Name">core</string>
        </Properties>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">Constants</string>
            <string name="Source">local Color3 = Color3

local Constants = {
    -- Currency
    CURRENCY = {
        STARTING_COINS = 100,
        MAX_COINS = 999999,
        REWARD_INTERVAL = 60, -- seconds
        REWARD_RATE = 1, -- coins per minute
        MIN_REWARD_AMOUNT = 1,
        MAX_REWARD_AMOUNT = 10,
        DAILY_BONUS = 50,
        WEEKLY_BONUS = 500,
        MONTHLY_BONUS = 2000,
        PRODUCTS = {
            {
                id = 1,
                coins = 100,
                robux = 10
            },
            {
                id = 2,
                coins = 500,
                robux = 40
            },
            {
                id = 3,
                coins = 1000,
                robux = 75
            },
            {
                id = 4,
                coins = 5000,
                robux = 350
            }
        }
    },
    
    -- UI
    UI_COLORS = {
        PRIMARY = Color3.fromRGB(0, 170, 255),
        SECONDARY = Color3.fromRGB(40, 40, 40),
        TEXT = Color3.fromRGB(255, 255, 255),
        ERROR = Color3.fromRGB(255, 50, 50)
    },
    
    -- Game Settings
    GAME = {
        MAX_INVENTORY_SLOTS = 50,
        PLACEMENT_COOLDOWN = 0.5,
        MAX_PLACEMENTS_PER_PLAYER = 1000,
        STARTING_CURRENCY = 1000,
        MAX_PLACED_ITEMS = 100
    },
    
    -- Item Actions
    ITEM_ACTIONS = {
        BUY = "buy",
        MOVE = "move",
        ROTATE = "rotate",
        COLOR = "color",
        DESTROY = "destroy",
        clone = {
            cost = 50,
            description = "Create a copy of this item"
        },
        move = {
            cost = 25,
            description = "Move this item to a new location"
        },
        rotate = {
            cost = 10,
            description = "Rotate this item"
        },
        destroy = {
            cost = 0,
            description = "Remove this item"
        }
    },

    ITEM_PRICING = {
        basic = 5,        -- 5 Robux
        secondary = 20,   -- 20 Robux
        rare = 100,       -- 100 Robux
        exclusive = 500,  -- 500 Robux
        clone = 10,       -- Fee for cloning
        move = 2,         -- Fee for moving
        destroy = 1,      -- Fee for destroying
        rotate = 1        -- Fee for rotating
    },

    -- Item definitions
    ITEMS = {
        basic_cube = {
            name = "Basic Cube",
            description = "A simple cube for building",
            price = 100,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "basic"
        },
        premium_cube = {
            name = "Premium Cube",
            description = "A fancy cube with special effects",
            price = 500,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "premium"
        },
        rare_cube = {
            name = "Rare Cube",
            description = "An extremely rare cube with unique properties",
            price = 1000,
            icon = "rbxassetid://0", -- Replace with actual icon
            category = "rare"
        }
    },
    
    -- UI Constants
    UI = {
        DIALOG_ANIMATION_DURATION = 0.3,
        BUTTON_HOVER_DURATION = 0.2,
        ERROR_DISPLAY_DURATION = 2
    }
}

return Constants</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="6">
          <Properties>
            <string name="Name">GameManager</string>
            <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local RunService = game:GetService("RunService")

local Constants = require(script.Parent.Constants)

-- Determine if we're on the server
local IS_SERVER = RunService:IsServer()

-- Create GameManager as proper OOP class
local GameManager = {}
GameManager.__index = GameManager

function GameManager.new()
    local self = setmetatable({}, GameManager)
    
    -- Shared properties for both server and client
    self.remotes = ReplicatedStorage:WaitForChild("Remotes")
    self.constants = Constants
    
    if IS_SERVER then
        self.playerData = {}
        
        -- Initialize DataStores on server
        local DataStoreService = game:GetService("DataStoreService")
        self.PlayerCurrencyStore = DataStoreService:GetDataStore("PlayerCurrency")
        self.PlayerInventoryStore = DataStoreService:GetDataStore("PlayerInventory")
        self.PlacedItemsStore = DataStoreService:GetDataStore("PlacedItems")
    end
    
    return self
end

-- Server-only functionality
if IS_SERVER then
    local Players = game:GetService("Players")
    
    -- Helper: skip DataStore in Studio
    function GameManager:canUseDataStore()
        return not RunService:IsStudio()
    end
    
    -- Initialize player data
    function GameManager:initializePlayerData(player)
        self.playerData[player.UserId] = {
            currency = self.constants.GAME.STARTING_CURRENCY,
            inventory = {},
            placedItems = {}
        }
        
        if self:canUseDataStore() then
            local success, result = pcall(function()
                local currency = self.PlayerCurrencyStore:GetAsync(player.UserId)
                local inventory = self.PlayerInventoryStore:GetAsync(player.UserId)
                local placedItems = self.PlacedItemsStore:GetAsync(player.UserId)
                
                if currency then self.playerData[player.UserId].currency = currency end
                if inventory then self.playerData[player.UserId].inventory = inventory end
                if placedItems then self.playerData[player.UserId].placedItems = placedItems end
            end)
            
            if not success then 
                warn("Failed to load data for", player.Name, ":", result) 
            end
        end
    end
    
    -- Save player data
    function GameManager:savePlayerData(player)
        local userId = player.UserId
        if not self.playerData[userId] then return end
        
        if self:canUseDataStore() then
            local success, result = pcall(function()
                self.PlayerCurrencyStore:SetAsync(userId, self.playerData[userId].currency)
                self.PlayerInventoryStore:SetAsync(userId, self.playerData[userId].inventory)
                self.PlacedItemsStore:SetAsync(userId, self.playerData[userId].placedItems)
            end)
            
            if not success then 
                warn("Failed to save data for", player.Name, ":", result) 
            end
        end
    end
    
    -- Update client UI
    function GameManager:updateClientUI(player)
        if self.remotes.UpdateBalance then
            self.remotes.UpdateBalance:FireClient(player, self.playerData[player.UserId].currency)
        end
        -- You can add more remotes for inventory if needed
    end
    
    -- Initialize method
    function GameManager:Initialize()
        print("Initializing GameManager...")
        
        -- Player join/leave events
        Players.PlayerAdded:Connect(function(player)
            self:initializePlayerData(player)
            self:updateClientUI(player)
        end)
        
        Players.PlayerRemoving:Connect(function(player)
            self:savePlayerData(player)
            self.playerData[player.UserId] = nil
        end)
        
        print("GameManager initialized successfully")
    end
    
    -- Purchase logic
    function GameManager:HandleBuyItem(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        local itemData = self.constants.ITEMS[itemId]
        
        if not pdata or not itemData then
            return { success = false, message = "Invalid item or player." }
        end
        
        if pdata.currency &lt; itemData.price then
            return { success = false, message = "Not enough currency." }
        end
        
        pdata.currency = pdata.currency - itemData.price
        pdata.inventory[itemId] = (pdata.inventory[itemId] or 0) + 1
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Purchase successful!" }
    end
    
    -- Placement logic
    function GameManager:HandlePlaceItem(player, itemId, position, rotation)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.inventory[itemId] or pdata.inventory[itemId] &lt;= 0 then
            return { success = false, message = "You do not have this item in your inventory." }
        end
        
        -- Placement validation (stub: always true)
        local validPlacement = true -- TODO: add collision/grid checks
        if not validPlacement then
            return { success = false, message = "Invalid placement location." }
        end
        
        pdata.inventory[itemId] = pdata.inventory[itemId] - 1
        
        -- Add to placedItems
        local placedId = tostring(os.time()) .. tostring(math.random(1000,9999))
        pdata.placedItems[placedId] = { id = itemId, position = position, rotation = rotation }
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item placed successfully!" }
    end
    
    -- Remove item logic
    function GameManager:HandleRemoveItem(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot remove this item." }
        end
        
        pdata.placedItems[itemId] = nil
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item removed successfully!" }
    end
    
    -- Move/Rotate logic
    function GameManager:HandleMoveItem(player, itemId, newPosition)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot move this item." }
        end
        
        pdata.placedItems[itemId].position = newPosition
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item moved successfully!" }
    end
    
    function GameManager:HandleRotateItem(player, itemId, newRotation)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot rotate this item." }
        end
        
        pdata.placedItems[itemId].rotation = newRotation
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item rotated successfully!" }
    end
    
    function GameManager:HandleChangeColor(player, itemId, newColor)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata or not pdata.placedItems[itemId] then
            return { success = false, message = "You cannot change the color of this item." }
        end
        
        pdata.placedItems[itemId].color = newColor
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item color changed successfully!" }
    end
    
    function GameManager:GetPlayerInventory(player)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata then
            return { success = false, message = "Player data not found." }
        end
        
        return { success = true, inventory = pdata.inventory, currency = pdata.currency }
    end
    
    function GameManager:GetItemData(itemId)
        return self.constants.ITEMS[itemId]
    end
    
    function GameManager:GetItemPlacement(itemId)
        -- This would check all players' placed items for the specified ID
        -- For simplicity, we're just returning nil for now
        for userId, pdata in pairs(self.playerData) do
            if pdata.placedItems[itemId] then
                return pdata.placedItems[itemId]
            end
        end
        return nil
    end
    
    function GameManager:AddToInventory(player, itemId)
        local userId = player.UserId
        local pdata = self.playerData[userId]
        
        if not pdata then
            return { success = false, message = "Player data not found." }
        end
        
        pdata.inventory[itemId] = (pdata.inventory[itemId] or 0) + 1
        self:savePlayerData(player)
        self:updateClientUI(player)
        
        return { success = true, message = "Item added to inventory!" }
    end
    
    function GameManager:ApplyItemEffect(player, itemId, placement)
        -- Implement item effect logic here
        -- For now, just return success
        return { success = true, message = "Item effect applied!" }
    end
end

-- Client-only functionality
if not IS_SERVER then
    function GameManager:Initialize()
        print("Initializing GameManager client...")
        -- Client initialization code here
        print("GameManager client initialized successfully")
    end
end

return GameManager</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="7">
          <Properties>
            <string name="Name">economy</string>
            <string name="Source"><![CDATA[local Economy = {}
Economy.CurrencyManager = require(script.CurrencyManager)
return Economy ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="8">
            <Properties>
              <string name="Name">CurrencyManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local DataStoreService = game:GetService("DataStoreService")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(script.Parent.Parent.Constants)

local CurrencyManager = {}
CurrencyManager.__index = CurrencyManager

-- Initialize a new CurrencyManager
function CurrencyManager.new()
    local self = setmetatable({}, CurrencyManager)
    self.playerBalances = {}
    self.currencyStore = DataStoreService:GetDataStore("PlayerCurrency")
    self.rewardTimers = {}
    self:Initialize()
    return self
end

-- Initialize the CurrencyManager
function CurrencyManager:Initialize()
    -- Set up player handling
    self:SetupPlayerHandling()
    
    -- Set up marketplace handling
    self:SetupMarketplaceHandling()
end

-- Set up player handling
function CurrencyManager:SetupPlayerHandling()
    game.Players.PlayerAdded:Connect(function(player)
        self:OnPlayerJoined(player)
    end)
    
    game.Players.PlayerRemoving:Connect(function(player)
        self:OnPlayerLeaving(player)
    end)
end

-- Set up marketplace handling
function CurrencyManager:SetupMarketplaceHandling()
    -- Handle purchase requests
    MarketplaceService.ProcessReceipt = function(receiptInfo)
        local player = game.Players:GetPlayerByUserId(receiptInfo.PlayerId)
        if not player then
            return Enum.ProductPurchaseDecision.NotProcessedYet
        end
        
        -- Process the purchase
        local success = self:ProcessPurchase(player, receiptInfo)
        if success then
            return Enum.ProductPurchaseDecision.PurchaseGranted
        else
            return Enum.ProductPurchaseDecision.NotProcessedYet
        end
    end
end

-- Handle player joining
function CurrencyManager:OnPlayerJoined(player)
    -- Initialize player balance
    self:InitializePlayerBalance(player)
    
    -- Start reward timer
    self:StartRewardTimer(player)
    
    -- Check for daily/weekly/monthly bonuses
    self:CheckLoginBonuses(player)
end

-- Handle player leaving
function CurrencyManager:OnPlayerLeaving(player)
    -- Stop reward timer
    self:StopRewardTimer(player)
    
    -- Save player balance
    self:SavePlayerBalance(player)
end

-- Initialize player balance
function CurrencyManager:InitializePlayerBalance(player)
    local balance = {
        coins = 0,
        lastRewardTime = os.time(),
        lastDailyBonus = 0,
        lastWeeklyBonus = 0,
        lastMonthlyBonus = 0
    }
    
    self.playerBalances[player.UserId] = balance
    
    -- Load saved balance
    self:LoadPlayerBalance(player)
end

-- Load player balance from DataStore
function CurrencyManager:LoadPlayerBalance(player)
    local success, result = pcall(function()
        return self.currencyStore:GetAsync(player.UserId)
    end)
    
    if success and result then
        self.playerBalances[player.UserId] = result
    end
end

-- Save player balance to DataStore
function CurrencyManager:SavePlayerBalance(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    pcall(function()
        self.currencyStore:SetAsync(player.UserId, balance)
    end)
end

-- Start reward timer for player
function CurrencyManager:StartRewardTimer(player)
    local timer = task.spawn(function()
        while player and player.Parent do
            task.wait(Constants.CURRENCY.REWARD_INTERVAL)
            self:GiveReward(player)
        end
    end)
    
    self.rewardTimers[player.UserId] = timer
end

-- Stop reward timer for player
function CurrencyManager:StopRewardTimer(player)
    local timer = self.rewardTimers[player.UserId]
    if timer then
        task.cancel(timer)
        self.rewardTimers[player.UserId] = nil
    end
end

-- Give reward to player
function CurrencyManager:GiveReward(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    -- Calculate reward amount
    local rewardAmount = math.floor(Constants.CURRENCY.REWARD_RATE * (Constants.CURRENCY.REWARD_INTERVAL / 60))
    rewardAmount = math.clamp(rewardAmount, Constants.CURRENCY.MIN_REWARD_AMOUNT, Constants.CURRENCY.MAX_REWARD_AMOUNT)
    
    -- Add reward to balance
    balance.coins = balance.coins + rewardAmount
    balance.lastRewardTime = os.time()
    
    -- Update player
    self:UpdatePlayerBalance(player)
end

-- Check login bonuses
function CurrencyManager:CheckLoginBonuses(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    local currentTime = os.time()
    
    -- Check daily bonus
    if currentTime - balance.lastDailyBonus >= 86400 then -- 24 hours
        balance.coins = balance.coins + Constants.CURRENCY.DAILY_BONUS
        balance.lastDailyBonus = currentTime
    end
    
    -- Check weekly bonus
    if currentTime - balance.lastWeeklyBonus >= 604800 then -- 7 days
        balance.coins = balance.coins + Constants.CURRENCY.WEEKLY_BONUS
        balance.lastWeeklyBonus = currentTime
    end
    
    -- Check monthly bonus
    if currentTime - balance.lastMonthlyBonus >= 2592000 then -- 30 days
        balance.coins = balance.coins + Constants.CURRENCY.MONTHLY_BONUS
        balance.lastMonthlyBonus = currentTime
    end
    
    -- Update player
    self:UpdatePlayerBalance(player)
end

-- Update player balance
function CurrencyManager:UpdatePlayerBalance(player)
    local balance = self.playerBalances[player.UserId]
    if not balance then return end
    
    -- Update player attributes
    player:SetAttribute("Coins", balance.coins)
    
    -- Fire client event
    ReplicatedStorage.Remotes.UpdateBalance:FireClient(player, balance.coins)
end

-- Get player balance
function CurrencyManager:GetBalance(player)
    local balance = self.playerBalances[player.UserId]
    return balance and balance.coins or 0
end

-- Add coins to player
function CurrencyManager:AddCoins(player, amount)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    balance.coins = balance.coins + amount
    self:UpdatePlayerBalance(player)
    return true
end

-- Remove coins from player
function CurrencyManager:RemoveCoins(player, amount)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    if balance.coins < amount then
        return false
    end
    
    balance.coins = balance.coins - amount
    self:UpdatePlayerBalance(player)
    return true
end

-- Process Robux purchase
function CurrencyManager:ProcessPurchase(player, receiptInfo)
    -- Get product info
    local productId = receiptInfo.ProductId
    local productInfo = self:GetProductInfo(productId)
    if not productInfo then return false end
    
    -- Add coins to player
    return self:AddCoins(player, productInfo.coins)
end

-- Get product info
function CurrencyManager:GetProductInfo(productId)
    -- TODO: Implement product info lookup
    return nil
end

-- Check if player can afford item
function CurrencyManager:CanAffordItem(player, itemId, useRobux)
    local balance = self.playerBalances[player.UserId]
    if not balance then return false end
    
    -- Get item price
    local price = self:GetItemPrice(itemId, useRobux)
    if not price then return false end
    
    if useRobux then
        -- Check Robux balance
        return player:GetAttribute("Robux") >= price
    else
        -- Check coin balance
        return balance.coins >= price
    end
end

-- Get item price
function CurrencyManager:GetItemPrice(itemId, useRobux)
    -- TODO: Implement item price lookup
    return nil
end

return CurrencyManager ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="9">
          <Properties>
            <string name="Name">interaction</string>
            <string name="Source"><![CDATA[local Interaction = {}
Interaction.Manager = require(script.InteractionManager)
return Interaction ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">InteractionManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local InteractionManager = {}
InteractionManager.__index = InteractionManager

function InteractionManager.new()
    local self = setmetatable({}, InteractionManager)
    self.interactions = {}
    return self
end

function InteractionManager:Initialize()
    print("InteractionManager initialized")
    self:RegisterDefaultInteractions()
end

function InteractionManager:RegisterInteraction(itemId, interactionType, callback)
    if not self.interactions[itemId] then
        self.interactions[itemId] = {}
    end
    
    self.interactions[itemId][interactionType] = callback
end

function InteractionManager:UnregisterInteraction(itemId, interactionType)
    if self.interactions[itemId] then
        self.interactions[itemId][interactionType] = nil
    end
end

function InteractionManager:HandleInteraction(player, itemId, interactionType, ...)
    if not self.interactions[itemId] or not self.interactions[itemId][interactionType] then
        -- Try default interactions if specific ones don't exist
        if self.interactions["default"] and self.interactions["default"][interactionType] then
            return self.interactions["default"][interactionType](player, itemId, ...)
        end
        return false
    end
    
    return self.interactions[itemId][interactionType](player, ...)
end

-- Default interactions
function InteractionManager:RegisterDefaultInteractions()
    -- Pick up interaction
    self:RegisterInteraction("default", "pickup", function(player, itemId, placement)
        -- Check if player can pick up the item
        if not placement or not placement.model then return false end
        
        -- Get player's inventory
        local inventory = ReplicatedStorage.Remotes.GetInventory:InvokeServer(player)
        if not inventory then return false end
        
        -- Check if inventory has space
        if #inventory >= Constants.GAME.MAX_INVENTORY_SIZE then
            -- Notify player inventory is full
            ReplicatedStorage.Remotes.NotifyPlayer:FireClient(player, "Inventory is full!")
            return false
        end
        
        -- Remove item from world
        placement.model:Destroy()
        
        -- Add to inventory
        ReplicatedStorage.Remotes.AddToInventory:FireServer(player, itemId)
        
        return true
    end)
    
    -- Use interaction
    self:RegisterInteraction("default", "use", function(player, itemId, placement)
        -- Check if item can be used
        if not placement or not placement.model then return false end
        
        -- Get item data
        local itemData = ReplicatedStorage.Remotes.GetItemData:InvokeServer(itemId)
        if not itemData then return false end
        
        -- Check if item has use effect
        if itemData.useEffect then
            -- Apply effect
            ReplicatedStorage.Remotes.ApplyItemEffect:FireServer(player, itemId, placement)
        end
        
        return true
    end)
    
    -- Examine interaction
    self:RegisterInteraction("default", "examine", function(player, itemId, placement)
        -- Get item data
        local itemData = ReplicatedStorage.Remotes.GetItemData:InvokeServer(itemId)
        if not itemData then return false end
        
        -- Show item description
        ReplicatedStorage.Remotes.ShowItemDescription:FireClient(player, itemData.description)
        
        return true
    end)
    
    -- Custom interactions for specific items
    self:RegisterInteraction("glow_cube", "change_color", function(player, itemId, placement)
        if not placement or not placement.model then return false end
        
        -- Get current color
        local currentColor = placement.model:GetAttribute("Color") or "White"
        
        -- Get next color
        local colors = {"Red", "Green", "Blue", "Yellow", "Purple", "White"}
        local currentIndex = table.find(colors, currentColor) or 1
        local nextIndex = (currentIndex % #colors) + 1
        local newColor = colors[nextIndex]
        
        -- Update color
        placement.model:SetAttribute("Color", newColor)
        
        -- Update visual
        for _, part in ipairs(placement.model:GetDescendants()) do
            if part:IsA("BasePart") then
                part.Color = Constants.UI_COLORS[newColor:upper()]
            end
        end
        
        return true
    end)
end

return InteractionManager ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="11">
          <Properties>
            <string name="Name">inventory</string>
            <string name="Source"><![CDATA[local Inventory = {}
Inventory.Manager = require(script.InventoryManager)
Inventory.ItemManager = require(script.ItemManager)
return Inventory ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="12">
            <Properties>
              <string name="Name">InventoryManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local InventoryManager = {}
InventoryManager.__index = InventoryManager

function InventoryManager.new()
    local self = setmetatable({}, InventoryManager)
    self.playerInventories = {}
    return self
end

function InventoryManager:Initialize()
    print("InventoryManager initialized")
end

function InventoryManager:InitializePlayer(player)
    self.playerInventories[player.UserId] = {
        items = {},
        maxSlots = Constants.GAME.MAX_INVENTORY_SLOTS
    }
end

function InventoryManager:CleanupPlayer(player)
    self.playerInventories[player.UserId] = nil
end

function InventoryManager:GetInventory(player)
    return self.playerInventories[player.UserId]
end

function InventoryManager:AddItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    if #inventory.items >= inventory.maxSlots then
        return false
    end
    
    table.insert(inventory.items, {
        id = itemId,
        quantity = quantity
    })
    
    return true
end

function InventoryManager:RemoveItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    for i, item in ipairs(inventory.items) do
        if item.id == itemId then
            if item.quantity > quantity then
                item.quantity = item.quantity - quantity
            else
                table.remove(inventory.items, i)
            end
            return true
        end
    end
    
    return false
end

function InventoryManager:HasItem(player, itemId, quantity)
    quantity = quantity or 1
    local inventory = self:GetInventory(player)
    if not inventory then return false end
    
    for _, item in ipairs(inventory.items) do
        if item.id == itemId and item.quantity >= quantity then
            return true
        end
    end
    
    return false
end

return InventoryManager
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="13">
            <Properties>
              <string name="Name">ItemManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local Constants = require(script.Parent.Parent.Constants)

local ItemManager = {}
ItemManager.__index = ItemManager

function ItemManager.new()
    local self = setmetatable({}, ItemManager)
    self.items = {}
    self.categories = {}
    self.properties = {}
    self.tiers = {}
    self.tierAssignments = {}
    self.interactions = {}
    self.adminUsers = {} -- List of user IDs that are admins
    return self
end

function ItemManager:Initialize()
    print("Initializing ItemManager...")
    local success = self:LoadItems()
    if success then
        print("ItemManager successfully loaded " .. #self.items .. " items")
    else
        warn("ItemManager failed to load items properly, using fallback data")
    end
end

function ItemManager:LoadItems()
    -- Try to load items from Structure.txt in GameData
    local success, result = pcall(function()
        -- Look for Structure.txt in multiple possible locations
        local structureFile
        local structureText = ""
        
        -- Try in ReplicatedStorage.GameData
        if ReplicatedStorage:FindFirstChild("GameData") and 
           ReplicatedStorage.GameData:FindFirstChild("Structure") then
            structureFile = ReplicatedStorage.GameData.Structure
            structureText = structureFile.Value
            print("Found Structure.txt in ReplicatedStorage.GameData")
        end
        
        -- Try in ServerStorage.GameData if not found
        if not structureFile and ServerStorage:FindFirstChild("GameData") and
           ServerStorage.GameData:FindFirstChild("Structure") then
            structureFile = ServerStorage.GameData.Structure
            structureText = structureFile.Value
            print("Found Structure.txt in ServerStorage.GameData")
        end
        
        -- Try at workspace root
        if not structureFile and workspace:FindFirstChild("Structure") then
            structureFile = workspace.Structure
            structureText = structureFile.Value
            print("Found Structure.txt in workspace")
        end
        
        if not structureText or structureText == "" then            -- If we can't find it in game, try to load from file directly
            local scriptPath = script:GetFullName()
            local basePath = string.match(scriptPath, "^(.*[/\\])") or ""
            
            -- Try direct reference
            local structureModule = require(script.Parent.Parent.Parent.Parent.Structure)
            if structureModule then
                structureText = structureModule
                print("Found Structure via module require")
            end
            
            if not structureText or structureText == "" then
                error("Structure.txt not found or empty")
                return false
            end
        end
        
        if structureText and structureText ~= "" then
            self:ParseStructureData(structureText)
            return true
        else
            error("Structure.txt not found or empty")
            return false
        end
    end)
    
    if not success then
        warn("Failed to load items from Structure.txt: " .. tostring(result))
        -- Fallback to default items
        self:LoadDefaultItems()
        return false
    end
    
    return true
end

function ItemManager:LoadDefaultItems()
    print("Using fallback item definitions")
    self.items = {
        {
            id = "brick_cube",
            name = "Brick Cube",
            price = 100,
            model = nil
        },
        {
            id = "wood_cube",
            name = "Wood Cube",
            price = 150,
            model = nil
        },
        {
            id = "stone_cube",
            name = "Stone Cube",
            price = 175,
            model = nil
        },
        {
            id = "glass_cube",
            name = "Glass Cube",
            price = 200,
            model = nil
        }
    }
    
    -- Setup minimal categories
    self.categories = {
        basic = {"brick_cube", "wood_cube", "stone_cube", "glass_cube"}
    }
end

function ItemManager:ParseStructureData(structureText)
    local currentSection = nil
    
    -- Reset data structures
    self.items = {}
    self.categories = {}
    self.properties = {}
    self.tiers = {}
    self.tierAssignments = {}
    self.interactions = {}
    
    -- Create a table to quickly lookup items by ID
    local itemsById = {}
    
    -- Parse the structure file line by line
    for line in string.gmatch(structureText, "[^\r\n]+") do
        -- Skip empty lines and comments
        if line:match("^%s*$") or line:match("^%s*#") then
            -- Skip this line (empty or comment)
        
        -- Check for section headers
        elseif line:match("^%s*%[(.+)%]%s*$") then
            currentSection = line:match("^%s*%[(.+)%]%s*$")
            print("Parsing section: " .. currentSection)
            
        -- Process items
        elseif currentSection == "Items" then
            local id, details = line:match("^%s*([%w_]+)%s*=%s*(.+)")
            if id and details then
                local name, price = details:match("^(.+),(%d+)$")
                if name and price then
                    local item = {
                        id = id,
                        name = name,
                        price = tonumber(price),
                        model = nil -- Will be loaded later
                    }
                    table.insert(self.items, item)
                    itemsById[id] = item
                    print("Added item: " .. id .. " = " .. name .. ", " .. price)
                end
            end
            
        -- Process categories
        elseif currentSection == "Categories" then
            local categoryName, items = line:match("^%s*([%w_]+)%s*=%s*(.+)")
            if categoryName and items then
                self.categories[categoryName] = {}
                for itemId in string.gmatch(items, "([^,]+)") do
                    itemId = itemId:match("^%s*(.-)%s*$") -- Trim whitespace
                    table.insert(self.categories[categoryName], itemId)
                end
                print("Added category: " .. categoryName .. " with " .. #self.categories[categoryName] .. " items")
            end
            
        -- Process properties
        elseif currentSection == "Properties" then
            local itemId, propString = line:match("^%s*([%w_]+)%s*=%s*(.+)")
            if itemId and propString then
                self.properties[itemId] = {}
                for prop in string.gmatch(propString, "([^,]+)") do
                    local key, value = prop:match("([^:]+):(.+)")
                    if key and value then
                        key = key:match("^%s*(.-)%s*$") -- Trim whitespace
                        value = value:match("^%s*(.-)%s*$") -- Trim whitespace
                        self.properties[itemId][key] = value
                    end
                end
                print("Added properties for: " .. itemId)
            end
            
        -- Process tiers
        elseif currentSection == "Tiers" then
            local tierName, price = line:match("^%s*([%w_]+)%s*=%s*(%d+)")
            if tierName and price then
                self.tiers[tierName] = tonumber(price)
                print("Added tier: " .. tierName .. " = " .. price)
            end
            
        -- Process tier assignments
        elseif currentSection == "TierAssignments" then
            local tierName, items = line:match("^%s*([%w_]+)%s*=%s*(.+)")
            if tierName and items then
                self.tierAssignments[tierName] = {}
                for itemId in string.gmatch(items, "([^,]+)") do
                    itemId = itemId:match("^%s*(.-)%s*$") -- Trim whitespace
                    table.insert(self.tierAssignments[tierName], itemId)
                end
                print("Added tier assignment: " .. tierName .. " with " .. #self.tierAssignments[tierName] .. " items")
            end
            
        -- Process interactions
        elseif currentSection == "Interactions" then
            local itemId, interactions = line:match("^%s*([%w_]+)%s*=%s*(.+)")
            if itemId and interactions then
                self.interactions[itemId] = {}
                for interaction in string.gmatch(interactions, "([^,]+)") do
                    interaction = interaction:match("^%s*(.-)%s*$") -- Trim whitespace
                    table.insert(self.interactions[itemId], interaction)
                end
                print("Added interactions for: " .. itemId)
            end
        end
    end
    
    -- Apply properties to items
    for itemId, props in pairs(self.properties) do
        local item = itemsById[itemId]
        if item then
            for key, value in pairs(props) do
                item[key] = value
            end
        end
    end
    
    print("Structure parsing complete")
    print("Items: " .. #self.items)
    
    local categoriesCount = 0
    for _ in pairs(self.categories) do
        categoriesCount = categoriesCount + 1
    end
    print("Categories: " .. categoriesCount)
    
    return true
end

function ItemManager:IsAdmin(player)
    return self.adminUsers[player.UserId] == true
end

function ItemManager:IsItemFree(itemId, player)
    -- Use the new pricing logic
    local price = self:GetActionPrice(itemId, Constants.ITEM_ACTIONS.BUY, player)
    return price == 0
end

function ItemManager:GetActionPrice(itemId, action, player)
    -- First check tier-based pricing
    for tierName, items in pairs(self.tierAssignments) do
        for _, id in ipairs(items) do
            if id == itemId then
                return self.tiers[tierName] or 0
            end
        end
    end
    
    -- Look for the item model in Workspace > Items
    local itemsFolder = workspace:FindFirstChild("Items")
    if itemsFolder then
        for _, model in ipairs(itemsFolder:GetChildren()) do
            if model:IsA("Model") and model:GetAttribute("item") and model.Name == itemId then
                local tier = model:GetAttribute("item")
                local price = Constants.ITEM_PRICING[tier]
                if price then
                    return price
                end
            end
        end
    end
    
    -- Fallback to item's direct price
    local item = self:GetItemData(itemId)
    return item and item.price or 0
end

function ItemManager:GetItemData(itemId)
    for _, item in ipairs(self.items) do
        if item.id == itemId then
            return item
        end
    end
    return nil
end

function ItemManager:GetItemModel(itemId)
    local item = self:GetItemData(itemId)
    return item and item.model
end

function ItemManager:GetItemsByCategory(categoryName)
    local category = self.categories[categoryName]
    if not category then
        return {}
    end
    
    local items = {}
    for _, itemId in ipairs(category) do
        local item = self:GetItemData(itemId)
        if item then
            table.insert(items, item)
        end
    end
    
    return items
end

function ItemManager:GetItemInteractions(itemId)
    return self.interactions[itemId] or {"examine"}
end

function ItemManager:GetAllCategories()
    local result = {}
    for categoryName, _ in pairs(self.categories) do
        table.insert(result, categoryName)
    end
    return result
end

return ItemManager
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">placement</string>
            <string name="Source"><![CDATA[local Placement = {}
Placement.Manager = require(script.PlacementManager)
return Placement ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="15">
            <Properties>
              <string name="Name">PlacementManager</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Constants = require(script.Parent.Parent.Constants)

local PlacementManager = {}
PlacementManager.__index = PlacementManager

function PlacementManager.new()
    local self = setmetatable({}, PlacementManager)
    self.placements = {}
    self.lastPlacementTime = {}
    self.interactionManager = nil
    return self
end

function PlacementManager:Initialize()
    print("PlacementManager initialized")
    
    -- Initialize interaction manager
    self.interactionManager = require(script.Parent.Parent.interaction.InteractionManager).new()
    self.interactionManager:Initialize()
    self.interactionManager:RegisterDefaultInteractions()
end

function PlacementManager:PlaceItem(player, itemId, position, rotation)
    -- Check cooldown
    if not self:CheckPlacementCooldown(player) then
        return false
    end
    
    -- Create placement
    local placement = {
        id = itemId,
        position = position,
        rotation = rotation,
        owner = player.UserId,
        model = nil, -- TODO: Create actual model
        interactions = {
            enabled = true,
            types = {"pickup", "use", "examine"}
        }
    }
    
    -- Add to placements
    table.insert(self.placements, placement)
    
    -- Update last placement time
    self.lastPlacementTime[player.UserId] = os.time()
    
    return true
end

function PlacementManager:MoveItem(player, placedItem, newPosition)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update position
    placement.position = newPosition
    
    return true
end

function PlacementManager:RotateItem(player, placedItem, newRotation)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update rotation
    placement.rotation = newRotation
    
    return true
end

function PlacementManager:ChangeItemColor(player, placedItem, newColor)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Update color
    placement.color = newColor
    
    return true
end

function PlacementManager:RemoveItem(player, placedItem)
    -- Find placement
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check ownership
    if placement.owner ~= player.UserId then return false end
    
    -- Remove placement
    for i, p in ipairs(self.placements) do
        if p == placement then
            table.remove(self.placements, i)
            break
        end
    end
    
    return true
end

function PlacementManager:FindPlacement(placedItem)
    for _, placement in ipairs(self.placements) do
        if placement == placedItem then
            return placement
        end
    end
    return nil
end

function PlacementManager:CheckPlacementCooldown(player)
    local lastTime = self.lastPlacementTime[player.UserId]
    if not lastTime then return true end
    
    return os.time() - lastTime >= Constants.GAME.PLACEMENT_COOLDOWN
end

-- Interaction methods
function PlacementManager:EnableInteractions(placedItem)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    placement.interactions.enabled = true
    return true
end

function PlacementManager:DisableInteractions(placedItem)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    placement.interactions.enabled = false
    return true
end

function PlacementManager:AddInteractionType(placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    if not table.find(placement.interactions.types, interactionType) then
        table.insert(placement.interactions.types, interactionType)
    end
    
    return true
end

function PlacementManager:RemoveInteractionType(placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    for i, type in ipairs(placement.interactions.types) do
        if type == interactionType then
            table.remove(placement.interactions.types, i)
            break
        end
    end
    
    return true
end

function PlacementManager:HandleInteraction(player, placedItem, interactionType)
    local placement = self:FindPlacement(placedItem)
    if not placement then return false end
    
    -- Check if interactions are enabled
    if not placement.interactions.enabled then return false end
    
    -- Check if interaction type is allowed
    if not table.find(placement.interactions.types, interactionType) then return false end
    
    -- Handle the interaction
    return self.interactionManager:HandleInteraction(player, placement.id, interactionType, placement)
end

return PlacementManager
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">ui</string>
            <string name="Source"><![CDATA[local UI = {}
UI.PurchaseDialog = require(script.PurchaseDialog)
UI.InventoryUI = require(script.InventoryUI)
UI.CurrencyUI = require(script.CurrencyUI)
UI.PlacedItemDialog = require(script.PlacedItemDialog)
return UI ]]></string>
          </Properties>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">CurrencyUI</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(script.Parent.Parent.Parent.core.Constants)

local CurrencyUI = {}
CurrencyUI.__index = CurrencyUI

-- Initialize a new CurrencyUI
function CurrencyUI.new()
    local self = setmetatable({}, CurrencyUI)
    self.ui = nil
    return self
end

-- Initialize the CurrencyUI
function CurrencyUI:Initialize()
    -- Create UI
    self:CreateUI()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Initial balance update
    self:UpdateBalance(Constants.CURRENCY.STARTING_COINS)
end

-- Create UI
function CurrencyUI:CreateUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CurrencyUI"
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    -- Create main frame
    local frame = Instance.new("Frame")
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(0, 200, 0, 50)
    frame.Position = UDim2.new(1, -220, 0, 20)
    frame.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    frame.BorderSizePixel = 0
    frame.Parent = screenGui
    
    -- Create coin icon
    local coinIcon = Instance.new("ImageLabel")
    coinIcon.Name = "CoinIcon"
    coinIcon.Size = UDim2.new(0, 30, 0, 30)
    coinIcon.Position = UDim2.new(0, 10, 0.5, -15)
    coinIcon.BackgroundTransparency = 1
    coinIcon.Image = "rbxassetid://101567167458494" -- TODO: Add coin icon
    coinIcon.Parent = frame
    
    -- Create balance label
    local balanceLabel = Instance.new("TextLabel")
    balanceLabel.Name = "BalanceLabel"
    balanceLabel.Size = UDim2.new(0, 100, 1, 0)
    balanceLabel.Position = UDim2.new(0, 50, 0, 0)
    balanceLabel.BackgroundTransparency = 1
    balanceLabel.TextColor3 = Constants.UI_COLORS.TEXT
    balanceLabel.TextSize = 18
    balanceLabel.Font = Enum.Font.GothamBold
    balanceLabel.Text = "0"
    balanceLabel.Parent = frame
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0, 30, 0, 30)
    purchaseButton.Position = UDim2.new(1, -40, 0.5, -15)
    purchaseButton.BackgroundColor3 = Constants.UI_COLORS.PRIMARY
    purchaseButton.Text = "+"
    purchaseButton.TextColor3 = Constants.UI_COLORS.TEXT
    purchaseButton.TextSize = 20
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Parent = frame
    
    self.ui = screenGui
end

-- Set up event handlers
function CurrencyUI:SetupEventHandlers()
    -- Handle balance updates
    ReplicatedStorage.Remotes.UpdateBalance.OnClientEvent:Connect(function(balance)
        self:UpdateBalance(balance)
    end)
    
    -- Handle purchase button click
    self.ui.MainFrame.PurchaseButton.MouseButton1Click:Connect(function()
        self:ShowPurchaseMenu()
    end)
end

-- Update balance display
function CurrencyUI:UpdateBalance(balance)
    self.ui.MainFrame.BalanceLabel.Text = tostring(balance)
end

-- Show purchase menu
function CurrencyUI:ShowPurchaseMenu()
    -- Create purchase menu
    local menu = Instance.new("Frame")
    menu.Name = "PurchaseMenu"
    menu.Size = UDim2.new(0, 300, 0, 400)
    menu.Position = UDim2.new(0.5, -150, 0.5, -200)
    menu.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    menu.BorderSizePixel = 0
    menu.Parent = self.ui
    
    -- Create close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Constants.UI_COLORS.ERROR
    closeButton.Text = "X"
    closeButton.TextColor3 = Constants.UI_COLORS.TEXT
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = menu
    
    -- Create purchase options
    local yOffset = 50
    for _, product in ipairs(Constants.CURRENCY.PRODUCTS) do
        local option = Instance.new("TextButton")
        option.Name = "Option_" .. product.id
        option.Size = UDim2.new(0, 260, 0, 60)
        option.Position = UDim2.new(0.5, -130, 0, yOffset)
        option.BackgroundColor3 = Constants.UI_COLORS.PRIMARY
        option.Text = string.format("%d Coins - %d Robux", product.coins, product.robux)
        option.TextColor3 = Constants.UI_COLORS.TEXT
        option.TextSize = 18
        option.Font = Enum.Font.GothamBold
        option.Parent = menu
        
        option.MouseButton1Click:Connect(function()
            MarketplaceService:PromptProductPurchase(Players.LocalPlayer, product.id)
        end)
        
        yOffset = yOffset + 70
    end
    
    -- Handle close button
    closeButton.MouseButton1Click:Connect(function()
        menu:Destroy()
    end)
end

return CurrencyUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="18">
            <Properties>
              <string name="Name">InventoryUI</string>
              <string name="Source"><![CDATA[-- InventoryUI.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local InventoryUI = {}

-- UI Constants
local INVENTORY_SIZE = UDim2.new(0, 600, 0, 400)
local INVENTORY_POSITION = UDim2.new(0.5, -300, 0.5, -200)
local ANIMATION_DURATION = 0.3
local ITEM_SIZE = UDim2.new(0, 100, 0, 120)
local ITEMS_PER_ROW = 5
local ITEM_PADDING = 10

-- Create the inventory UI
local function createInventory(parent)
    local inventory = Instance.new("Frame")
    inventory.Name = "InventoryUI"
    inventory.Size = INVENTORY_SIZE
    inventory.Position = INVENTORY_POSITION
    inventory.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    inventory.BorderSizePixel = 0
    inventory.Visible = false
    inventory.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = inventory
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = inventory
    
    -- Title bar
    local titleBar = Instance.new("Frame")
    titleBar.Name = "TitleBar"
    titleBar.Size = UDim2.new(1, 0, 0, 50)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    titleBar.BorderSizePixel = 0
    titleBar.Parent = inventory
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = titleBar
    
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, -100, 1, 0)
    title.Position = UDim2.new(0, 20, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.Text = "Inventory"
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar
    
    local currency = Instance.new("TextLabel")
    currency.Name = "Currency"
    currency.Size = UDim2.new(0, 100, 1, 0)
    currency.Position = UDim2.new(1, -120, 0, 0)
    currency.BackgroundTransparency = 1
    currency.Font = Enum.Font.GothamBold
    currency.Text = "0"
    currency.TextSize = 20
    currency.TextColor3 = Color3.fromRGB(255, 215, 0)
    currency.TextXAlignment = Enum.TextXAlignment.Right
    currency.Parent = titleBar
    
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.TextSize = 18
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Parent = titleBar
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton
    
    -- Items container
    local itemsContainer = Instance.new("ScrollingFrame")
    itemsContainer.Name = "ItemsContainer"
    itemsContainer.Size = UDim2.new(1, -40, 1, -70)
    itemsContainer.Position = UDim2.new(0, 20, 0, 60)
    itemsContainer.BackgroundTransparency = 1
    itemsContainer.BorderSizePixel = 0
    itemsContainer.ScrollBarThickness = 6
    itemsContainer.ScrollingDirection = Enum.ScrollingDirection.Y
    itemsContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    itemsContainer.Parent = inventory
    
    -- Create grid layout
    local gridLayout = Instance.new("UIGridLayout")
    gridLayout.CellSize = ITEM_SIZE
    gridLayout.CellPadding = UDim2.new(0, ITEM_PADDING, 0, ITEM_PADDING)
    gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
    gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    gridLayout.Parent = itemsContainer
    
    return inventory
end

-- Create an item button
local function createItemButton(itemName, itemData, quantity)
    local button = Instance.new("TextButton")
    button.Name = itemName
    button.Size = ITEM_SIZE
    button.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    button.AutoButtonColor = false
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    -- Item icon (placeholder)
    local icon = Instance.new("ImageLabel")
    icon.Name = "Icon"
    icon.Size = UDim2.new(1, -20, 0, 60)
    icon.Position = UDim2.new(0, 10, 0, 10)
    icon.BackgroundTransparency = 1
    icon.Image = itemData.icon or "rbxassetid://0" -- Replace with actual icon
    icon.Parent = button
    
    -- Item name
    local name = Instance.new("TextLabel")
    name.Name = "Name"
    name.Size = UDim2.new(1, -20, 0, 20)
    name.Position = UDim2.new(0, 10, 0, 80)
    name.BackgroundTransparency = 1
    name.Font = Enum.Font.GothamBold
    name.Text = itemName
    name.TextSize = 14
    name.TextColor3 = Color3.new(1, 1, 1)
    name.TextTruncate = Enum.TextTruncate.AtEnd
    name.Parent = button
    
    -- Quantity
    local quantityLabel = Instance.new("TextLabel")
    quantityLabel.Name = "Quantity"
    quantityLabel.Size = UDim2.new(1, -20, 0, 20)
    quantityLabel.Position = UDim2.new(0, 10, 0, 100)
    quantityLabel.BackgroundTransparency = 1
    quantityLabel.Font = Enum.Font.Gotham
    quantityLabel.Text = "x" .. quantity
    quantityLabel.TextSize = 14
    quantityLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    quantityLabel.Parent = button
    
    -- Hover effect
    button.MouseEnter:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        TweenService:Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        }):Play()
    end)
    
    return button
end

-- Initialize the inventory UI
function InventoryUI.Initialize(parent)
    local inventory = createInventory(parent)
    
    -- Set up close button
    inventory.TitleBar.CloseButton.MouseButton1Click:Connect(function()
        InventoryUI.Hide()
    end)
    
    -- Store inventory reference
    InventoryUI._inventory = inventory
end

-- Update inventory display
function InventoryUI.UpdateInventory(inventory, currency)
    local ui = InventoryUI._inventory
    if not ui then return end
    
    -- Update currency
    ui.TitleBar.Currency.Text = tostring(currency or 0)
    
    -- Clear existing items
    local container = ui.ItemsContainer
    for _, child in ipairs(container:GetChildren()) do
        if child:IsA("TextButton") then
            child:Destroy()
        end
    end
    
    -- Add items
    local itemCount = 0
    for itemName, quantity in pairs(inventory) do
        if quantity > 0 then
            local itemData = Constants.ITEMS[itemName]
            if itemData then
                local button = createItemButton(itemName, itemData, quantity)
                button.Parent = container
                
                -- Set up click handler
                button.MouseButton1Click:Connect(function()
                    if InventoryUI.OnItemSelected then
                        InventoryUI.OnItemSelected(itemName)
                    end
                end)
                
                itemCount = itemCount + 1
            end
        end
    end
    
    -- Update canvas size
    local rows = math.ceil(itemCount / ITEMS_PER_ROW)
    container.CanvasSize = UDim2.new(0, 0, 0, rows * (ITEM_SIZE.Y.Offset + ITEM_PADDING) + ITEM_PADDING)
end

-- Show the inventory
function InventoryUI.Show()
    local inventory = InventoryUI._inventory
    if not inventory then return end
    
    inventory.Visible = true
    inventory.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(inventory, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the inventory
function InventoryUI.Hide()
    local inventory = InventoryUI._inventory
    if not inventory then return end
    
    local hideTween = TweenService:Create(inventory, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        inventory.Visible = false
    end)
    
    hideTween:Play()
end

return InventoryUI ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="19">
            <Properties>
              <string name="Name">PlacedItemDialog</string>
              <string name="Source"><![CDATA[-- PlacedItemDialog.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local PlacedItemDialog = {}

-- UI Constants
local DIALOG_SIZE = UDim2.new(0, 300, 0, 400)
local DIALOG_POSITION = UDim2.new(0.5, -150, 0.5, -200)
local ANIMATION_DURATION = 0.3
local BUTTON_HEIGHT = 50
local BUTTON_PADDING = 10

-- Create the dialog UI
local function createDialog(parent)
    local dialog = Instance.new("Frame")
    dialog.Name = "PlacedItemDialog"
    dialog.Size = DIALOG_SIZE
    dialog.Position = DIALOG_POSITION
    dialog.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    dialog.BorderSizePixel = 0
    dialog.Visible = false
    dialog.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = dialog
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = dialog
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 50)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    title.BorderSizePixel = 0
    title.Font = Enum.Font.GothamBold
    title.Text = "Item Actions"
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Parent = dialog
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 8)
    titleCorner.Parent = title
    
    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.TextSize = 18
    closeButton.TextColor3 = Color3.new(1, 1, 1)
    closeButton.Parent = title
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0, 4)
    closeCorner.Parent = closeButton
    
    -- Actions container
    local actionsContainer = Instance.new("Frame")
    actionsContainer.Name = "ActionsContainer"
    actionsContainer.Size = UDim2.new(1, -40, 1, -70)
    actionsContainer.Position = UDim2.new(0, 20, 0, 60)
    actionsContainer.BackgroundTransparency = 1
    actionsContainer.Parent = dialog
    
    -- Create action buttons
    local actions = {
        { name = "Clone", color = Color3.fromRGB(0, 120, 0), cost = Constants.ITEM_ACTIONS.clone.cost },
        { name = "Move", color = Color3.fromRGB(0, 120, 200), cost = Constants.ITEM_ACTIONS.move.cost },
        { name = "Rotate", color = Color3.fromRGB(200, 120, 0), cost = Constants.ITEM_ACTIONS.rotate.cost },
        { name = "Destroy", color = Color3.fromRGB(200, 0, 0), cost = Constants.ITEM_ACTIONS.destroy.cost }
    }
    
    for i, action in ipairs(actions) do
        local button = Instance.new("TextButton")
        button.Name = action.name
        button.Size = UDim2.new(1, 0, 0, BUTTON_HEIGHT)
        button.Position = UDim2.new(0, 0, 0, (i-1) * (BUTTON_HEIGHT + BUTTON_PADDING))
        button.BackgroundColor3 = action.color
        button.Font = Enum.Font.GothamBold
        button.Text = string.format("%s (%d)", action.name, action.cost)
        button.TextSize = 18
        button.TextColor3 = Color3.new(1, 1, 1)
        button.Parent = actionsContainer
        
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 4)
        buttonCorner.Parent = button
        
        -- Hover effect
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = action.color:Lerp(Color3.new(1, 1, 1), 0.2)
            }):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundColor3 = action.color
            }):Play()
        end)
    end
    
    return dialog
end

-- Initialize the dialog
function PlacedItemDialog.Initialize(parent)
    local dialog = createDialog(parent)
    local currentItemId = nil
    
    -- Set up close button
    dialog.Title.CloseButton.MouseButton1Click:Connect(function()
        PlacedItemDialog.Hide()
    end)
    
    -- Set up action buttons
    for _, button in ipairs(dialog.ActionsContainer:GetChildren()) do
        if button:IsA("TextButton") then
            button.MouseButton1Click:Connect(function()
                if PlacedItemDialog.OnActionSelected and currentItemId then
                    PlacedItemDialog.OnActionSelected(currentItemId, button.Name:lower())
                end
                PlacedItemDialog.Hide()
            end)
        end
    end
    
    -- Store dialog reference
    PlacedItemDialog._dialog = dialog
end

-- Show the dialog
function PlacedItemDialog.Show(itemId, itemName)
    local dialog = PlacedItemDialog._dialog
    if not dialog then return end
    
    currentItemId = itemId
    dialog.Title.Text = itemName or "Item Actions"
    
    -- Show dialog with animation
    dialog.Visible = true
    dialog.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the dialog
function PlacedItemDialog.Hide()
    local dialog = PlacedItemDialog._dialog
    if not dialog then return end
    
    local hideTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        dialog.Visible = false
    end)
    
    hideTween:Play()
end

return PlacedItemDialog ]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="20">
            <Properties>
              <string name="Name">PurchaseDialog</string>
              <string name="Source"><![CDATA[-- PurchaseDialog.lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local Constants = require(script.Parent.Parent.Constants)

local PurchaseDialog = {}

-- UI Constants
local DIALOG_SIZE = UDim2.new(0, 400, 0, 300)
local DIALOG_POSITION = UDim2.new(0.5, -200, 0.5, -150)
local ANIMATION_DURATION = 0.3

-- Create the dialog UI
local function createDialog(parent)
    local dialog = Instance.new("Frame")
    dialog.Name = "PurchaseDialog"
    dialog.Size = DIALOG_SIZE
    dialog.Position = DIALOG_POSITION
    dialog.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    dialog.BorderSizePixel = 0
    dialog.Visible = false
    dialog.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = dialog
    
    -- Add shadow
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://5554236805"
    shadow.ImageColor3 = Color3.new(0, 0, 0)
    shadow.ImageTransparency = 0.6
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(23, 23, 277, 277)
    shadow.ZIndex = -1
    shadow.Parent = dialog
    
    -- Title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 40)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 24
    title.TextColor3 = Color3.new(1, 1, 1)
    title.Parent = dialog
    
    -- Item info
    local itemInfo = Instance.new("TextLabel")
    itemInfo.Name = "ItemInfo"
    itemInfo.Size = UDim2.new(1, -40, 0, 60)
    itemInfo.Position = UDim2.new(0, 20, 0, 50)
    itemInfo.BackgroundTransparency = 1
    itemInfo.Font = Enum.Font.Gotham
    itemInfo.TextSize = 16
    itemInfo.TextColor3 = Color3.fromRGB(200, 200, 200)
    itemInfo.TextWrapped = true
    itemInfo.Parent = dialog
    
    -- Price
    local price = Instance.new("TextLabel")
    price.Name = "Price"
    price.Size = UDim2.new(1, -40, 0, 30)
    price.Position = UDim2.new(0, 20, 0, 120)
    price.BackgroundTransparency = 1
    price.Font = Enum.Font.GothamBold
    price.TextSize = 20
    price.TextColor3 = Color3.fromRGB(255, 215, 0)
    price.Parent = dialog
    
    -- Quantity selector
    local quantityFrame = Instance.new("Frame")
    quantityFrame.Name = "QuantityFrame"
    quantityFrame.Size = UDim2.new(1, -40, 0, 40)
    quantityFrame.Position = UDim2.new(0, 20, 0, 160)
    quantityFrame.BackgroundTransparency = 1
    quantityFrame.Parent = dialog
    
    local minusButton = Instance.new("TextButton")
    minusButton.Name = "MinusButton"
    minusButton.Size = UDim2.new(0, 40, 1, 0)
    minusButton.Position = UDim2.new(0, 0, 0, 0)
    minusButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    minusButton.Font = Enum.Font.GothamBold
    minusButton.Text = "-"
    minusButton.TextSize = 24
    minusButton.TextColor3 = Color3.new(1, 1, 1)
    minusButton.Parent = quantityFrame
    
    local quantityLabel = Instance.new("TextLabel")
    quantityLabel.Name = "Quantity"
    quantityLabel.Size = UDim2.new(1, -80, 1, 0)
    quantityLabel.Position = UDim2.new(0, 40, 0, 0)
    quantityLabel.BackgroundTransparency = 1
    quantityLabel.Font = Enum.Font.GothamBold
    quantityLabel.Text = "1"
    quantityLabel.TextSize = 20
    quantityLabel.TextColor3 = Color3.new(1, 1, 1)
    quantityLabel.Parent = quantityFrame
    
    local plusButton = Instance.new("TextButton")
    plusButton.Name = "PlusButton"
    plusButton.Size = UDim2.new(0, 40, 1, 0)
    plusButton.Position = UDim2.new(1, -40, 0, 0)
    plusButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    plusButton.Font = Enum.Font.GothamBold
    plusButton.Text = "+"
    plusButton.TextSize = 24
    plusButton.TextColor3 = Color3.new(1, 1, 1)
    plusButton.Parent = quantityFrame
    
    -- Add corner radius to buttons
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = minusButton
    
    local plusButtonCorner = buttonCorner:Clone()
    plusButtonCorner.Parent = plusButton
    
    -- Buttons
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Name = "ButtonFrame"
    buttonFrame.Size = UDim2.new(1, -40, 0, 40)
    buttonFrame.Position = UDim2.new(0, 20, 1, -60)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = dialog
    
    local cancelButton = Instance.new("TextButton")
    cancelButton.Name = "CancelButton"
    cancelButton.Size = UDim2.new(0.5, -10, 1, 0)
    cancelButton.Position = UDim2.new(0, 0, 0, 0)
    cancelButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    cancelButton.Font = Enum.Font.GothamBold
    cancelButton.Text = "Cancel"
    cancelButton.TextSize = 18
    cancelButton.TextColor3 = Color3.new(1, 1, 1)
    cancelButton.Parent = buttonFrame
    
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0.5, -10, 1, 0)
    purchaseButton.Position = UDim2.new(0.5, 10, 0, 0)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 120, 0)
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Text = "Purchase"
    purchaseButton.TextSize = 18
    purchaseButton.TextColor3 = Color3.new(1, 1, 1)
    purchaseButton.Parent = buttonFrame
    
    -- Add corner radius to buttons
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 4)
    buttonCorner.Parent = cancelButton
    
    local purchaseButtonCorner = buttonCorner:Clone()
    purchaseButtonCorner.Parent = purchaseButton
    
    return dialog
end

-- Initialize the dialog
function PurchaseDialog.Initialize(parent)
    local dialog = createDialog(parent)
    local quantity = 1
    local currentItem = nil
    local onPurchase = nil
    
    -- Update price display
    local function updatePrice()
        if not currentItem then return end
        local itemData = Constants.ITEMS[currentItem]
        if not itemData then return end
        
        local totalPrice = itemData.price * quantity
        dialog.Price.Text = string.format("Price: %d", totalPrice)
    end
    
    -- Update quantity
    local function updateQuantity(newQuantity)
        quantity = math.max(1, math.min(99, newQuantity))
        dialog.QuantityFrame.Quantity.Text = tostring(quantity)
        updatePrice()
    end
    
    -- Set up quantity buttons
    dialog.QuantityFrame.MinusButton.MouseButton1Click:Connect(function()
        updateQuantity(quantity - 1)
    end)
    
    dialog.QuantityFrame.PlusButton.MouseButton1Click:Connect(function()
        updateQuantity(quantity + 1)
    end)
    
    -- Set up purchase button
    dialog.ButtonFrame.PurchaseButton.MouseButton1Click:Connect(function()
        if onPurchase then
            onPurchase(quantity)
        end
        PurchaseDialog.Hide()
    end)
    
    -- Set up cancel button
    dialog.ButtonFrame.CancelButton.MouseButton1Click:Connect(function()
        PurchaseDialog.Hide()
    end)
    
    -- Store dialog reference
    PurchaseDialog._dialog = dialog
end

-- Show the dialog
function PurchaseDialog.Show(itemName, callback)
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    local itemData = Constants.ITEMS[itemName]
    if not itemData then return end
    
    -- Update dialog content
    dialog.Title.Text = itemName
    dialog.ItemInfo.Text = itemData.description or "No description available"
    currentItem = itemName
    onPurchase = callback
    
    -- Reset quantity
    updateQuantity(1)
    
    -- Show dialog with animation
    dialog.Visible = true
    dialog.BackgroundTransparency = 1
    
    local showTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 0
    })
    showTween:Play()
end

-- Hide the dialog
function PurchaseDialog.Hide()
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    local hideTween = TweenService:Create(dialog, TweenInfo.new(ANIMATION_DURATION), {
        BackgroundTransparency = 1
    })
    
    hideTween.Completed:Connect(function()
        dialog.Visible = false
    end)
    
    hideTween:Play()
end

-- Show error message
function PurchaseDialog.ShowError(message)
    local dialog = PurchaseDialog._dialog
    if not dialog then return end
    
    dialog.ItemInfo.Text = "Error: " .. message
    dialog.ItemInfo.TextColor3 = Color3.fromRGB(255, 100, 100)
    
    -- Reset color after 2 seconds
    task.delay(2, function()
        if dialog.ItemInfo then
            dialog.ItemInfo.TextColor3 = Color3.fromRGB(200, 200, 200)
        end
    end)
end

return PurchaseDialog ]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="21">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="22">
      <Properties>
        <string name="Name">server</string>
        <token name="RunContext">0</token>
        <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local SharedModule = require(ReplicatedStorage.shared)
local GameManager = SharedModule.GameManager
local CurrencyManager = SharedModule.Economy.CurrencyManager
local InteractionManagerModule = SharedModule.Interaction.Manager
local interactionManager = InteractionManagerModule.new()
interactionManager:Initialize()

-- Create Remotes folder if it doesn't exist
if not ReplicatedStorage:FindFirstChild("Remotes") then
    local remotes = Instance.new("Folder")
    remotes.Name = "Remotes"
    remotes.Parent = ReplicatedStorage
end

-- Create remote events and functions
local remotes = ReplicatedStorage.Remotes
local events = {
    "BuyItem",
    "PlaceItem",
    "MoveItem",
    "RotateItem",
    "ChangeColor",
    "RemoveItem",
    "InteractWithItem",
    "AddToInventory",
    "ApplyItemEffect",
    "ShowItemDescription",
    "NotifyPlayer",
    "UpdateBalance"
}

local functions = {
    "GetInventory",
    "GetItemData",
    "GetAvailableInteractions"
}

-- Create RemoteEvents
for _, eventName in ipairs(events) do
    if not remotes:FindFirstChild(eventName) then
        local event = Instance.new("RemoteEvent")
        event.Name = eventName
        event.Parent = remotes
    end
end

-- Create RemoteFunctions
for _, functionName in ipairs(functions) do
    if not remotes:FindFirstChild(functionName) then
        local func = Instance.new("RemoteFunction")
        func.Name = functionName
        func.Parent = remotes
    end
end

-- Initialize managers with consistent OOP approach
local currencyManager = CurrencyManager.new()
currencyManager:Initialize()

-- Fix GameManager OOP approach - create instance instead of using module directly
local gameManager = GameManager.new()
gameManager:Initialize()

-- interactionManager is already initialized above using OOP pattern

-- Set up event handlers with gameManager instance
remotes.BuyItem.OnServerEvent:Connect(function(player, itemId)
    gameManager:HandleBuyItem(player, itemId)
end)

remotes.PlaceItem.OnServerEvent:Connect(function(player, itemId, position, rotation)
    gameManager:HandlePlaceItem(player, itemId, position, rotation)
end)

remotes.MoveItem.OnServerEvent:Connect(function(player, itemId, newPosition)
    gameManager:HandleMoveItem(player, itemId, newPosition)
end)

remotes.RotateItem.OnServerEvent:Connect(function(player, itemId, newRotation)
    gameManager:HandleRotateItem(player, itemId, newRotation)
end)

remotes.ChangeColor.OnServerEvent:Connect(function(player, itemId, newColor)
    gameManager:HandleChangeColor(player, itemId, newColor)
end)

remotes.RemoveItem.OnServerEvent:Connect(function(player, itemId)
    gameManager:HandleRemoveItem(player, itemId)
end)

remotes.GetInventory.OnServerInvoke = function(player)
    return gameManager:GetPlayerInventory(player)
end

remotes.GetItemData.OnServerInvoke = function(player, itemId)
    return gameManager:GetItemData(itemId)
end

remotes.InteractWithItem.OnServerEvent:Connect(function(player, placedItem, interactionType)
    local placement = gameManager:GetItemPlacement(placedItem.id)
    if not placement then return end
    local success = interactionManager:HandleInteraction(player, placedItem.id, interactionType, placement)
    if not success and remotes.NotifyPlayer then
        remotes.NotifyPlayer:FireClient(player, "Cannot interact with this item!")
    end
end)

remotes.GetAvailableInteractions.OnServerInvoke = function(player, placedItem)
    local placement = gameManager:GetItemPlacement(placedItem.id)
    if not placement then return {} end
    local itemData = gameManager:GetItemData(placedItem.id)
    if not itemData then return {} end
    local interactions = {"examine"}
    if not placement.locked then
        table.insert(interactions, "pickup")
    end
    if itemData.useEffect then
        table.insert(interactions, "use")
    end
    if itemData.customInteractions then
        for _, interaction in ipairs(itemData.customInteractions) do
            table.insert(interactions, interaction)
        end
    end
    return interactions
end

remotes.AddToInventory.OnServerEvent:Connect(function(player, itemId)
    gameManager:AddToInventory(player, itemId)
end)

remotes.ApplyItemEffect.OnServerEvent:Connect(function(player, itemId, placement)
    gameManager:ApplyItemEffect(player, itemId, placement)
end)

print("Server initialized successfully")</string>
      </Properties>
      <Item class="Folder" referent="23">
        <Properties>
          <string name="Name">Neon</string>
        </Properties>
        <Item class="Script" referent="24">
          <Properties>
            <string name="Name">NeonGlowManager</string>
            <token name="RunContext">0</token>
            <string name="Source">-- EnhancedGlowManager.lua
-- Place this in ServerScriptService

local TweenService = game:GetService("TweenService")
wait(1) -- Wait for everything to load

print("=== Enhanced Glow Manager Starting ===")

-- Color definitions
local GLOW_COLORS = {
	Red = Color3.fromRGB(255, 0, 0),
	Blue = Color3.fromRGB(0, 0, 255),
	Green = Color3.fromRGB(0, 255, 0),
	Purple = Color3.fromRGB(147, 39, 212),
	Yellow = Color3.fromRGB(255, 255, 0),
	Cyan = Color3.fromRGB(0, 255, 255),
	White = Color3.fromRGB(255, 255, 255),
	Orange = Color3.fromRGB(255, 128, 0)
}

-- Animation settings
local GLOW_TWEEN_INFO = TweenInfo.new(
	2,                      -- Duration
	Enum.EasingStyle.Sine,   -- Easing Style
	Enum.EasingDirection.InOut, -- Easing Direction
	-1,                     -- Repeat count (-1 = forever)
	true                    -- Reverse
)

-- Store tweens for cleanup
local activeTweens = {}

-- Recursively search through all containers
local function findAllGlowModels(parent)
	local glowModels = {}

	for _, child in ipairs(parent:GetChildren()) do
		if child:IsA("Model") and child:GetAttribute("GlowColor") then
			table.insert(glowModels, child)
		elseif child:IsA("Folder") then
			local nestedModels = findAllGlowModels(child)
			for _, model in ipairs(nestedModels) do
				table.insert(glowModels, model)
			end
		end
	end

	return glowModels
end

-- Create an outer glow effect (transparent part surrounding the cube)
local function createOuterGlow(part, color)
	local outerGlow = Instance.new("Part")
	outerGlow.Name = "OuterGlow"
	outerGlow.Parent = part.Parent
	outerGlow.Material = Enum.Material.Neon
	outerGlow.BrickColor = BrickColor.new(color)
	outerGlow.Color = color
	outerGlow.Anchored = true
	outerGlow.CanCollide = false
	outerGlow.Transparency = 0.7

	-- Handle different part types
	if part:IsA("Part") then
		outerGlow.Shape = part.Shape
	else
		-- For UnionOperations or other part types, default to Block
		outerGlow.Shape = Enum.PartType.Block
	end

	outerGlow.Size = part.Size * 1.1  -- Slightly larger
	outerGlow.CFrame = part.CFrame

	-- Keep it connected to the main part
	local weld = Instance.new("WeldConstraint")
	weld.Part0 = part
	weld.Part1 = outerGlow
	weld.Parent = part

	return outerGlow
end

-- Enhanced glow function
local function makePartGlow(part, color)
	print(string.format("  Enhancing glow for %s (%s)", part.Name, part.ClassName))

	-- 1. Set main part properties based on part type
	if part:IsA("Part") then
		part.Material = Enum.Material.ForceField  -- More translucent than Neon
	elseif part:IsA("UnionOperation") then
		-- UnionOperations have limited material options
		part.Material = Enum.Material.Neon
	end

	part.Color = color
	part.Transparency = 0.2  -- Slightly transparent

	-- 2. Add/update PointLight
	local light = part:FindFirstChild("PointLight") or Instance.new("PointLight")
	light.Parent = part
	light.Color = color
	light.Brightness = 3  -- Brighter
	light.Range = 15      -- Larger range

	-- 3. Create outer glow effect
	local outerGlow = createOuterGlow(part, color)

	-- 4. Add pulsing animation
	local brightColor = color
	local darkColor = Color3.new(color.R * 0.4, color.G * 0.4, color.B * 0.4)

	-- Animate main part
	local partTween = TweenService:Create(part, GLOW_TWEEN_INFO, {
		Color = darkColor,
		Transparency = 0.5
	})

	-- Animate outer glow
	local glowTween = TweenService:Create(outerGlow, GLOW_TWEEN_INFO, {
		Color = darkColor,
		Transparency = 0.9
	})

	-- Animate light
	local lightTween = TweenService:Create(light, GLOW_TWEEN_INFO, {
		Brightness = 1,
		Range = 8
	})

	-- Store tweens for later cleanup
	table.insert(activeTweens, partTween)
	table.insert(activeTweens, glowTween)
	table.insert(activeTweens, lightTween)

	-- Start animations
	partTween:Play()
	glowTween:Play()
	lightTween:Play()

	print(string.format("  âœ“ Enhanced glow applied to %s", part.Name))
end

-- Find all glow models in workspace
local allGlowModels = findAllGlowModels(workspace)
print(string.format("Found %d glow models", #allGlowModels))

-- Process each glow model
for _, model in ipairs(allGlowModels) do
	local colorName = model:GetAttribute("GlowColor")
	local color = GLOW_COLORS[colorName]

	if color then
		print(string.format("Processing: %s (Color: %s)", model.Name, colorName))

		-- Apply enhanced glow to all parts in the model
		for _, part in ipairs(model:GetChildren()) do
			if part:IsA("BasePart") then
				makePartGlow(part, color)
			end
		end
	else
		warn(string.format("Unknown color: %s for model: %s", colorName, model.Name))
	end
end

print("=== Enhanced Glow Manager Complete! ===")

-- Cleanup function
local function cleanup()
	for _, tween in ipairs(activeTweens) do
		tween:Cancel()
	end
	activeTweens = {}
end

-- Store for global access
_G.EnhancedGlowManager = {
	GLOW_COLORS = GLOW_COLORS,
	makePartGlow = makePartGlow,
	findAllGlowModels = findAllGlowModels,
	cleanup = cleanup
}</string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterGui" referent="25">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="LocalScript" referent="26">
      <Properties>
        <string name="Name">StarterGui</string>
        <string name="Source"><![CDATA[--[[
    StarterGui Module - ForeverBuild2
    
    This is the main initialization script for the StarterGui.
    It handles loading and setting up all UI components.
]]

-- Add debug print to confirm script is running
print("StarterGui script starting...")

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Get shared module
local SharedModule = require(ReplicatedStorage.shared)

-- Local references to commonly used modules
local Constants = SharedModule.Constants
local GameManagerModule = SharedModule.GameManager
local CurrencyManagerModule = SharedModule.Economy.CurrencyManager

-- Create manager instances
local gameManager = GameManagerModule.new()
local currencyManager = CurrencyManagerModule.new()

-- Initialize managers
gameManager:Initialize()
currencyManager:Initialize()

local StarterGui = {}
StarterGui.__index = StarterGui

function StarterGui.new()
    local self = setmetatable({}, StarterGui)
    self.remoteEvents = ReplicatedStorage.Remotes
    self.gameManager = gameManager
    self.currencyManager = currencyManager
    self.player = Players.LocalPlayer
    return self
end

function StarterGui:Init()
    print("Initializing StarterGui...")
    
    -- Create main UI
    self:CreateMainUI()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Set up error handling
    self:SetupErrorHandling()
end

function StarterGui:SetupErrorHandling()
    -- Global error handler for client-side errors
    game:GetService("ScriptContext").Error:Connect(function(message, stackTrace, script)
        if self.ui and self.ui.Parent then
            self:ShowNotification("Error: " .. message)
            warn("UI Error: " .. message .. "\n" .. stackTrace)
        end
    end)
end

function StarterGui:CreateMainUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "MainUI"
    screenGui.ResetOnSpawn = false -- Ensure UI persists across respawns
    screenGui.Parent = self.player:WaitForChild("PlayerGui")
    
    -- Create main frame
    local frame = Instance.new("Frame")
    frame.Name = "MainFrame"
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = screenGui
    
    self.ui = screenGui
end

function StarterGui:SetupEventHandlers()
    -- Handle item description
    self.remoteEvents.ShowItemDescription.OnClientEvent:Connect(function(description)
        self:ShowItemDescription(description)
    end)
    
    -- Handle notifications
    self.remoteEvents.NotifyPlayer.OnClientEvent:Connect(function(message)
        self:ShowNotification(message)
    end)
end

function StarterGui:ShowItemDescription(description)
    -- Create description UI
    local descriptionUI = Instance.new("ScreenGui")
    descriptionUI.Name = "ItemDescription"
    descriptionUI.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "DescriptionFrame"
    frame.Size = UDim2.new(0, 300, 0, 200)
    frame.Position = UDim2.new(0.5, -150, 0.5, -100)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = descriptionUI
    
    local label = Instance.new("TextLabel")
    label.Name = "DescriptionLabel"
    label.Size = UDim2.new(1, -20, 1, -20)
    label.Position = UDim2.new(0, 10, 0, 10)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 16
    label.Font = Enum.Font.Gotham
    label.Text = description
    label.TextWrapped = true
    label.Parent = frame
    
    -- Add close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Parent = frame
    
    closeButton.MouseButton1Click:Connect(function()
        descriptionUI:Destroy()
    end)
end

function StarterGui:ShowNotification(message)
    -- Create notification UI
    local notification = Instance.new("ScreenGui")
    notification.Name = "Notification"
    notification.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "NotificationFrame"
    frame.Size = UDim2.new(0, 300, 0, 50)
    frame.Position = UDim2.new(0.5, -150, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = notification
    
    local label = Instance.new("TextLabel")
    label.Name = "MessageLabel"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 18
    label.Font = Enum.Font.GothamBold
    label.Text = message
    label.Parent = frame
    
    -- Animate and destroy
    game:GetService("Debris"):AddItem(notification, 3)
end

-- Add this to self-initialize
StarterGui.new():Init()

return StarterGui
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="27">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="28">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="29">
        <Properties>
          <string name="Name">client</string>
          <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

-- Add debug print to confirm script is running
print("Client script starting...")

-- Load core modules
local SharedModule = require(ReplicatedStorage.shared)

-- Initialize all shared modules with consistent error handling
local success, errorMsg = pcall(function()
	SharedModule.Init() -- Ensure all shared systems are initialized
end)

if not success then
	warn("Failed to initialize SharedModule: ", errorMsg)
end

-- Set up proper OOP initialization for UI components
local UI = require(ReplicatedStorage.shared.core.ui)

-- Create UI instances with proper error handling
local function safeInitialize(module, name)
	local success, result = pcall(function()
		if typeof(module) == "table" and module.new then
			-- OOP style initialization
			local instance = module.new()
			instance:Initialize()
			return instance
		elseif typeof(module) == "table" and module.Initialize then
			-- Functional style initialization
			module.Initialize(Players.LocalPlayer.PlayerGui)
			return module
		else
			warn("Module " .. name .. " doesn't have proper initialization method")
			return nil
		end
	end)

	if not success then
		warn("Failed to initialize " .. name .. ": ", result)
		return nil
	end

	return result
end

-- Initialize UI components with error handling
local inventoryUI = safeInitialize(UI.InventoryUI, "InventoryUI")
local purchaseDialog = safeInitialize(UI.PurchaseDialog, "PurchaseDialog")
local currencyUI = safeInitialize(UI.CurrencyUI, "CurrencyUI")
local placedItemDialog = safeInitialize(UI.PlacedItemDialog, "PlacedItemDialog")

-- The interaction module is a child of this script
local InteractionSystem = require(script.interaction.InteractionSystem)

-- Initialize interaction system with OOP approach
local interactionSystem = InteractionSystem.new()
interactionSystem:Initialize()

print("Client initialized successfully")</string>
        </Properties>
        <Item class="Folder" referent="30">
          <Properties>
            <string name="Name">Currency</string>
          </Properties>
          <Item class="ModuleScript" referent="31">
            <Properties>
              <string name="Name">CurrencyUI</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")

local Constants = require(ReplicatedStorage.shared.core.Constants)

local CurrencyUI = {}
CurrencyUI.__index = CurrencyUI

-- Initialize a new CurrencyUI
function CurrencyUI.new()
    local self = setmetatable({}, CurrencyUI)
    self.player = Players.LocalPlayer
    self.ui = nil
    self:Initialize()
    return self
end

-- Initialize the CurrencyUI
function CurrencyUI:Initialize()
    -- Create UI
    self:CreateUI()
    
    -- Set up event handling
    self:SetupEventHandling()
    
    -- Initial balance update
    self:UpdateBalance(self.player:GetAttribute("Coins") or 0)
end

-- Create UI
function CurrencyUI:CreateUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CurrencyUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = self.player:WaitForChild("PlayerGui")
    
    -- Create main frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 200, 0, 50)
    mainFrame.Position = UDim2.new(1, -220, 0, 20)
    mainFrame.BackgroundTransparency = 0.5
    mainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    mainFrame.BorderSizePixel = 0
    mainFrame.Parent = screenGui
    
    -- Create coin icon
    local coinIcon = Instance.new("ImageLabel")
    coinIcon.Name = "CoinIcon"
    coinIcon.Size = UDim2.new(0, 40, 0, 40)
    coinIcon.Position = UDim2.new(0, 5, 0.5, -20)
    coinIcon.BackgroundTransparency = 1
    coinIcon.Image = "rbxassetid://101567167458494" -- TODO: Replace with actual coin icon
    coinIcon.Parent = mainFrame
    
    -- Create balance label
    local balanceLabel = Instance.new("TextLabel")
    balanceLabel.Name = "BalanceLabel"
    balanceLabel.Size = UDim2.new(1, -50, 1, 0)
    balanceLabel.Position = UDim2.new(0, 50, 0, 0)
    balanceLabel.BackgroundTransparency = 1
    balanceLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    balanceLabel.TextSize = 24
    balanceLabel.Font = Enum.Font.GothamBold
    balanceLabel.Text = "0"
    balanceLabel.TextXAlignment = Enum.TextXAlignment.Left
    balanceLabel.Parent = mainFrame
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(0, 100, 0, 30)
    purchaseButton.Position = UDim2.new(1, -110, 1, 10)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    purchaseButton.BorderSizePixel = 0
    purchaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    purchaseButton.TextSize = 18
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Text = "Buy Coins"
    purchaseButton.Parent = mainFrame
    
    -- Store UI reference
    self.ui = screenGui
end

-- Set up event handling
function CurrencyUI:SetupEventHandling()
    -- Handle balance updates
    ReplicatedStorage.Remotes.UpdateBalance.OnClientEvent:Connect(function(balance)
        self:UpdateBalance(balance)
    end)
    
    -- Handle purchase button click
    self.ui.MainFrame.PurchaseButton.MouseButton1Click:Connect(function()
        self:ShowPurchaseMenu()
    end)
end

-- Update balance display
function CurrencyUI:UpdateBalance(balance)
    self.ui.MainFrame.BalanceLabel.Text = tostring(balance)
end

-- Show purchase menu
function CurrencyUI:ShowPurchaseMenu()
    -- Create purchase menu
    local purchaseMenu = Instance.new("Frame")
    purchaseMenu.Name = "PurchaseMenu"
    purchaseMenu.Size = UDim2.new(0, 300, 0, 400)
    purchaseMenu.Position = UDim2.new(0.5, -150, 0.5, -200)
    purchaseMenu.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    purchaseMenu.BorderSizePixel = 0
    purchaseMenu.Parent = self.ui
    
    -- Create title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 50)
    title.BackgroundTransparency = 1
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 24
    title.Font = Enum.Font.GothamBold
    title.Text = "Purchase Coins"
    title.Parent = purchaseMenu
    
    -- Create close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -40, 0, 10)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.TextSize = 20
    closeButton.Font = Enum.Font.GothamBold
    closeButton.Text = "X"
    closeButton.Parent = purchaseMenu
    
    -- Create purchase options
    local yOffset = 60
    for _, product in ipairs(Constants.CURRENCY.PRODUCTS) do
        local option = self:CreatePurchaseOption(product, yOffset)
        option.Parent = purchaseMenu
        yOffset = yOffset + 80
    end
    
    -- Handle close button
    closeButton.MouseButton1Click:Connect(function()
        purchaseMenu:Destroy()
    end)
end

-- Create purchase option
function CurrencyUI:CreatePurchaseOption(product, yOffset)
    local option = Instance.new("Frame")
    option.Name = "Option_" .. product.id
    option.Size = UDim2.new(1, -40, 0, 70)
    option.Position = UDim2.new(0, 20, 0, yOffset)
    option.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    option.BorderSizePixel = 0
    
    -- Create coin amount
    local coinAmount = Instance.new("TextLabel")
    coinAmount.Name = "CoinAmount"
    coinAmount.Size = UDim2.new(0.6, 0, 1, 0)
    coinAmount.BackgroundTransparency = 1
    coinAmount.TextColor3 = Color3.fromRGB(255, 255, 255)
    coinAmount.TextSize = 20
    coinAmount.Font = Enum.Font.GothamBold
    coinAmount.Text = tostring(product.coins) .. " Coins"
    coinAmount.TextXAlignment = Enum.TextXAlignment.Left
    coinAmount.Parent = option
    
    -- Create price
    local price = Instance.new("TextLabel")
    price.Name = "Price"
    price.Size = UDim2.new(0.4, 0, 1, 0)
    price.Position = UDim2.new(0.6, 0, 0, 0)
    price.BackgroundTransparency = 1
    price.TextColor3 = Color3.fromRGB(255, 255, 255)
    price.TextSize = 20
    price.Font = Enum.Font.GothamBold
    price.Text = tostring(product.robux) .. " R$"
    price.TextXAlignment = Enum.TextXAlignment.Right
    price.Parent = option
    
    -- Create purchase button
    local purchaseButton = Instance.new("TextButton")
    purchaseButton.Name = "PurchaseButton"
    purchaseButton.Size = UDim2.new(1, 0, 0, 30)
    purchaseButton.Position = UDim2.new(0, 0, 1, 10)
    purchaseButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    purchaseButton.BorderSizePixel = 0
    purchaseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    purchaseButton.TextSize = 18
    purchaseButton.Font = Enum.Font.GothamBold
    purchaseButton.Text = "Purchase"
    purchaseButton.Parent = option
    
    -- Handle purchase button
    purchaseButton.MouseButton1Click:Connect(function()
        self:PurchaseCoins(product.id)
    end)
    
    return option
end

-- Purchase coins
function CurrencyUI:PurchaseCoins(productId)
    MarketplaceService:PromptProductPurchase(self.player, productId)
end

return CurrencyUI ]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="32">
          <Properties>
            <string name="Name">client</string>
            <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

-- Core modules
local SharedModule = require(ReplicatedStorage.shared)
local GameManager = SharedModule.GameManager
local Constants = SharedModule.Constants

-- UI Modules
local PurchaseDialog = SharedModule.UI.PurchaseDialog
local InventoryUI = SharedModule.UI.InventoryUI
local PlacedItemDialog = SharedModule.UI.PlacedItemDialog

-- Remote events/functions
local Remotes = GameManager.Remotes
local PurchaseItem = Remotes:WaitForChild("PurchaseItem")
local RequestInventory = Remotes:WaitForChild("RequestInventory")
local PlaceItem = Remotes:WaitForChild("PlaceItem")
local PlacedItemAction = Remotes:WaitForChild("PlacedItemAction")

-- State
local currentInventory = {}
local currentCurrency = 0
local isPlacingItem = false
local selectedItem = nil
local placementPreview = nil
local lastError = nil

-- Helper to safely call RemoteFunctions
local function safeInvoke(remote, ...)
    local ok, result = pcall(function(...)
        return remote:InvokeServer(...)
    end, ...)
    if not ok then
        lastError = "A network error occurred. Please try again."
        warn("RemoteFunction error:", result)
        return { success = false, message = lastError }
    end
    if not result or not result.success then
        lastError = (result and result.message) or "Unknown error."
        return { success = false, message = lastError }
    end
    lastError = nil
    return result
end

-- Create inventory button
local function createInventoryButton(parent)
    local button = Instance.new("TextButton")
    button.Name = "InventoryButton"
    button.Size = UDim2.new(0, 120, 0, 40)
    button.Position = UDim2.new(1, -140, 0, 20)
    button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    button.Font = Enum.Font.GothamBold
    button.Text = "Inventory"
    button.TextSize = 18
    button.TextColor3 = Color3.new(1, 1, 1)
    button.Parent = parent
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = button
    
    -- Add hover effect
    button.MouseEnter:Connect(function()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(60, 60, 60)
        }):Play()
    end)
    
    button.MouseLeave:Connect(function()
        game:GetService("TweenService"):Create(button, TweenInfo.new(0.2), {
            BackgroundColor3 = Color3.fromRGB(45, 45, 45)
        }):Play()
    end)
    
    -- Set up click handler
    button.MouseButton1Click:Connect(function()
        if lastError then
            inventoryUI:ShowError(lastError)
            return
        end
        local result = safeInvoke(RequestInventory)
        if result.success then
            currentInventory = result.inventory
            currentCurrency = result.currency
            inventoryUI:UpdateInventory(currentInventory, currentCurrency)
            inventoryUI:Show()
        else
            inventoryUI:ShowError(result.message)
        end
    end)
    
    return button
end

-- Initialize UI
local function initializeUI()
    -- Create main UI container
    local uiContainer = Instance.new("ScreenGui")
    uiContainer.Name = "ItemSystemUI"
    uiContainer.ResetOnSpawn = false
    uiContainer.Parent = player.PlayerGui
    
    -- Create inventory button
    createInventoryButton(uiContainer)
    
    -- Initialize UI modules
    local purchaseDialog = PurchaseDialog.new()
    purchaseDialog:Initialize(uiContainer)

    local inventoryUI = InventoryUI.new()
    inventoryUI:Initialize(uiContainer)

    local placedItemDialog = PlacedItemDialog.new()
    placedItemDialog:Initialize(uiContainer)
    
    -- Set up item selection
    inventoryUI.OnItemSelected = function(itemName)
        if lastError then
            inventoryUI:ShowError(lastError)
            return
        end
        if not currentInventory[itemName] or currentInventory[itemName] <= 0 then
            inventoryUI:ShowError("You do not own this item.")
            return
        end
        -- Start placement mode
        isPlacingItem = true
        selectedItem = itemName
        inventoryUI:Hide()
        -- Create placement preview
        if placementPreview then
            placementPreview:Destroy()
        end
        -- TODO: Create actual preview model based on item
        placementPreview = Instance.new("Part")
        placementPreview.Name = "PlacementPreview"
        placementPreview.Anchored = true
        placementPreview.CanCollide = false
        placementPreview.Transparency = 0.5
        placementPreview.Size = Vector3.new(4, 4, 4)
        placementPreview.BrickColor = BrickColor.new("Bright blue")
        placementPreview.Parent = workspace
    end
    
    -- Set up placed item interaction
    placedItemDialog.OnActionSelected = function(itemId, action)
        PlacedItemAction:FireServer(itemId, action)
    end
end

-- Handle proximity prompts
local function setupProximityPrompts()
    -- Find all items with proximity prompts
    local function onItemFound(item)
        if item:GetAttribute("item") then
            local prompt = item:FindFirstChild("ProximityPrompt")
            if not prompt then
                prompt = Instance.new("ProximityPrompt")
                prompt.Name = "ItemPrompt"
                prompt.ActionText = "Purchase"
                prompt.ObjectText = item:GetAttribute("item")
                prompt.HoldDuration = 0
                prompt.MaxActivationDistance = 10
                prompt.Parent = item
            end
            
            prompt.Triggered:Connect(function()
                if lastError then
                    purchaseDialog:ShowError(lastError)
                    return
                end
                local itemName = item:GetAttribute("item")
                if itemName then
                    purchaseDialog:Show(itemName, function(quantity)
                        local result = safeInvoke(PurchaseItem, itemName, quantity)
                        if result.success then
                            currentInventory = result.newInventory
                            currentCurrency = result.newCurrency
                            inventoryUI:UpdateInventory(currentInventory, currentCurrency)
                        else
                            purchaseDialog:ShowError(result.message)
                        end
                    end)
                end
            end)
        end
    end
    
    -- Set up existing items
    for _, item in ipairs(workspace:GetDescendants()) do
        onItemFound(item)
    end
    
    -- Watch for new items
    workspace.DescendantAdded:Connect(onItemFound)
end

-- Handle item placement
local function setupPlacement()
    local mouse = player:GetMouse()
    
    -- Handle mouse movement
    RunService.RenderStepped:Connect(function()
        if not isPlacingItem or not selectedItem or not placementPreview then return end
        
        -- Update preview position
        local hit, position, normal = workspace:FindPartOnRay(
            Ray.new(mouse.UnitRay.Origin, mouse.UnitRay.Direction * 100),
            placementPreview
        )
        
        if hit then
            placementPreview.CFrame = CFrame.new(position) * CFrame.new(0, placementPreview.Size.Y/2, 0)
        end
    end)
    
    -- Handle mouse clicks
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if isPlacingItem and selectedItem and placementPreview then
                -- Place item
                local position = placementPreview.Position
                local rotation = placementPreview.Orientation
                PlaceItem:FireServer(selectedItem, position, rotation)
                
                -- Reset placement mode
                isPlacingItem = false
                selectedItem = nil
                placementPreview:Destroy()
                placementPreview = nil
            end
        elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
            if isPlacingItem then
                -- Cancel placement
                isPlacingItem = false
                selectedItem = nil
                if placementPreview then
                    placementPreview:Destroy()
                    placementPreview = nil
                end
            end
        end
    end)
end

-- Initialize
print("Client script starting...")
initializeUI()
setupProximityPrompts()
setupPlacement()

-- Handle character respawning
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    -- Reset placement mode if active
    if isPlacingItem and placementPreview then
        isPlacingItem = false
        selectedItem = nil
        placementPreview:Destroy()
        placementPreview = nil
    end
end)

-- Initial inventory load
local result = safeInvoke(RequestInventory)
if result.success then
    currentInventory = result.inventory
    currentCurrency = result.currency
    inventoryUI:UpdateInventory(currentInventory, currentCurrency)
else
    inventoryUI:ShowError(result.message)
end ]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="33">
          <Properties>
            <string name="Name">interaction</string>
          </Properties>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">InteractionSystem</string>
              <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

-- Add debug print to confirm module is loading
print("InteractionSystem module loading...")

local Constants = require(ReplicatedStorage.shared.core.Constants)
-- Fix path references to use ReplicatedStorage.shared.core.ui
local PurchaseDialog = require(ReplicatedStorage.shared.core.ui.PurchaseDialog)
local InventoryUI = require(ReplicatedStorage.shared.core.ui.InventoryUI)
local PlacedItemDialog = require(ReplicatedStorage.shared.core.ui.PlacedItemDialog)

local InteractionSystem = {}
InteractionSystem.__index = InteractionSystem

function InteractionSystem.new()
    local self = setmetatable({}, InteractionSystem)
    self.player = Players.LocalPlayer
    self.mouse = self.player:GetMouse()
    self.currentTarget = nil
    self.interactionDistance = 10 -- Maximum distance for interaction
    self.ui = nil
    self.remoteEvents = ReplicatedStorage.Remotes
    return self
end

function InteractionSystem:Initialize()
    print("InteractionSystem initialized")
    
    -- Create UI
    self:CreateUI()
    
    -- Set up input handling
    self:SetupInputHandling()
    
    -- Set up mouse movement
    self:SetupMouseHandling()
    
    -- Set up event handlers
    self:SetupEventHandlers()
    
    -- Set up inventory key
    self:SetupInventoryKey()
end

function InteractionSystem:CreateUI()
    -- Create ScreenGui
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "InteractionUI"
    screenGui.Parent = self.player:WaitForChild("PlayerGui")
    
    -- Create tooltip
    local tooltip = Instance.new("Frame")
    tooltip.Name = "Tooltip"
    tooltip.Size = UDim2.new(0, 200, 0, 100)
    tooltip.BackgroundColor3 = Constants.UI_COLORS.SECONDARY
    tooltip.BorderSizePixel = 0
    tooltip.Visible = false
    tooltip.Parent = screenGui
    
    -- Create title
    local title = Instance.new("TextLabel")
    title.Name = "Title"
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.TextColor3 = Constants.UI_COLORS.TEXT
    title.TextSize = 18
    title.Font = Enum.Font.GothamBold
    title.Text = "Interact"
    title.Parent = tooltip
    
    -- Create interaction list
    local list = Instance.new("Frame")
    list.Name = "InteractionList"
    list.Size = UDim2.new(1, 0, 1, -30)
    list.Position = UDim2.new(0, 0, 0, 30)
    list.BackgroundTransparency = 1
    list.Parent = tooltip
    
    self.ui = screenGui
end

function InteractionSystem:SetupInputHandling()
    -- Handle interaction input (E key)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.E then
            self:AttemptInteraction()
        end
    end)
end

function InteractionSystem:SetupMouseHandling()
    -- Update current target on mouse movement
    game:GetService("RunService").RenderStepped:Connect(function()
        self:UpdateCurrentTarget()
    end)
end

function InteractionSystem:UpdateCurrentTarget()
    local target = self.mouse.Target
    if not target then
        self:ClearCurrentTarget()
        return
    end
    
    -- Check if target is a placed item
    local placedItem = self:GetPlacedItemFromPart(target)
    if not placedItem then
        self:ClearCurrentTarget()
        return
    end
    
    -- Check distance
    local distance = (target.Position - self.player.Character.HumanoidRootPart.Position).Magnitude
    if distance > self.interactionDistance then
        self:ClearCurrentTarget()
        return
    end
    
    -- Update current target
    self.currentTarget = placedItem
    
    -- Show interaction UI
    self:ShowInteractionUI(placedItem)
end

function InteractionSystem:ClearCurrentTarget()
    if self.currentTarget then
        self:HideInteractionUI()
        self.currentTarget = nil
    end
end

function InteractionSystem:GetPlacedItemFromPart(part)
    local current = part
    while current and current ~= workspace do
        if current:IsA("Model") and current:GetAttribute("item") then
            return {
                id = current.Name,
                model = current
            }
        end
        current = current.Parent
    end
    return nil
end

function InteractionSystem:ShowInteractionUI(placedItem)
    local tooltip = self.ui.Tooltip
    local list = tooltip.InteractionList
    tooltip.Visible = true -- Ensure tooltip is visible
    -- Clear existing interactions
    for _, child in ipairs(list:GetChildren()) do
        child:Destroy()
    end

    -- Get the item model from Workspace > Items
    local itemsFolder = workspace:FindFirstChild("Items")
    local itemModel = nil
    if itemsFolder then
        for _, model in ipairs(itemsFolder:GetDescendants()) do
            if model:IsA("Model") and model:GetAttribute("item") and model.Name == placedItem.id then
                itemModel = model
                break
            end
        end
    end

    -- Get tier and price
    local tier = itemModel and itemModel:GetAttribute("item") or "basic"
    local price = Constants.ITEM_PRICING[tier] or 0

    -- If this is a main item (not a placed item), show the purchase dialog
    if not placedItem.model:GetAttribute("PlacedByPlayer") then
        PurchaseDialog.Show(placedItem.id, function(quantity)
            local result = ReplicatedStorage.Remotes.BuyItem:InvokeServer(placedItem.id, quantity)
            if not result or not result.success then
                if result and result.message then
                    PurchaseDialog.ShowError(result.message)
                else
                    PurchaseDialog.ShowError("Purchase failed.")
                end
            end
        end)
        return
    end

    -- Otherwise, show the placed item dialog
    PlacedItemDialog.Show(placedItem.id, placedItem.model:GetAttribute("item"), function(action)
        if action == "clone" then
            ReplicatedStorage.Remotes.CloneItem:FireServer(placedItem)
        elseif action == "move" then
            ReplicatedStorage.Remotes.MoveItem:FireServer(placedItem)
        elseif action == "destroy" then
            ReplicatedStorage.Remotes.RemoveItem:FireServer(placedItem)
        elseif action == "rotate" then
            ReplicatedStorage.Remotes.RotateItem:FireServer(placedItem)
        end
    end)
end

function InteractionSystem:HideInteractionUI()
    self.ui.Tooltip.Visible = false
end

function InteractionSystem:AttemptInteraction()
    if not self.currentTarget then return end
    
    -- Get available interactions
    local interactions = self:GetAvailableInteractions(self.currentTarget)
    if not interactions or #interactions == 0 then return end
    
    -- If only one interaction is available, use it
    if #interactions == 1 then
        self:PerformInteraction(self.currentTarget, interactions[1])
        return
    end
    
    -- Show interaction menu
    self:ShowInteractionMenu(interactions)
end

function InteractionSystem:GetAvailableInteractions(placedItem)
    -- Request available interactions from server
    return ReplicatedStorage.Remotes.GetAvailableInteractions:InvokeServer(placedItem)
end

function InteractionSystem:PerformInteraction(placedItem, interactionType)
    -- Send interaction request to server
    ReplicatedStorage.Remotes.InteractWithItem:FireServer(placedItem, interactionType)
end

function InteractionSystem:ShowInteractionMenu(interactions)
    -- Use the same UI as ShowInteractionUI
    self:ShowInteractionUI(self.currentTarget)
end

function InteractionSystem:SetupEventHandlers()
    -- Handle interaction responses
    self.remoteEvents.NotifyPlayer.OnClientEvent:Connect(function(message)
        self:ShowNotification(message)
    end)
end

function InteractionSystem:ShowNotification(message)
    -- Create notification UI
    local notification = Instance.new("ScreenGui")
    notification.Name = "Notification"
    notification.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Name = "NotificationFrame"
    frame.Size = UDim2.new(0, 300, 0, 50)
    frame.Position = UDim2.new(0.5, -150, 0.1, 0)
    frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    frame.BorderSizePixel = 0
    frame.Parent = notification
    
    local label = Instance.new("TextLabel")
    label.Name = "MessageLabel"
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 18
    label.Font = Enum.Font.GothamBold
    label.Text = message
    label.Parent = frame
    
    -- Animate and destroy
    game:GetService("Debris"):AddItem(notification, 3)
end

function InteractionSystem:SetupInventoryKey()
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.KeyCode == Enum.KeyCode.I then
            self:OpenInventory()
        end
    end)
end

function InteractionSystem:OpenInventory()
    -- Fetch inventory from server
    local inventory = ReplicatedStorage.Remotes.GetInventory:InvokeServer()
    if not inventory or not inventory.success or not inventory.inventory or next(inventory.inventory) == nil then
        InventoryUI.ShowError("Your inventory is empty.")
        return
    end
    InventoryUI.Show()
    -- Add logic to update inventory display if needed
end

return InteractionSystem ]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>